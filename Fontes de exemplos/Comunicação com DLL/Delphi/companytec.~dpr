//------------------------------------------------------------------------------------------------------------
// Patrick Gonçalves Medeiros                                                                                =
// Companytec Automação e controle                                                                           =
// Criação: Sexta-Feira - 21 de Janeiro de 2020                                                              =
// Ultima compilação: Terça-Feira, 28/07/2020                                                                =
// DLL para automação de bombas                                                                              =
// Versão 5.9.0                                                                                              =
//------------------------------------------------------------------------------------------------------------

library companytec;

uses
  windows,
  SysUtils,
  forms,
  dateutils,
  Math,
  dialogs,
  extctrls,
  gets in 'gets.pas',
  io in 'io.pas',
  tray in 'tray.pas',
  dllcompanytec in 'dllcompanytec.pas',
  atc in 'atc.pas';

var
  Version:Info;
//  callbackmode:boolean;
//  CBFunction: TCallBackFunction;
//  ab:string;
//  CBTimer:ttimer;


//------------------------------------------------------------------------------------------------------------
// Função Ver                                                                                                =
// Entrada: estrutura Info (referência)                                                                      =
// Saída: estrutura Info   (referência)                                                                      =
// Sub-Functions: None                                                                                       =
//------------------------------------------------------------------------------------------------------------
Procedure Ver(var versao:info);stdcall; export;
begin
  versao.titulo:='Dll Companytec';
  versao.versao:='5.9.0';
  versao.data:='01/08/2022';
  versao.autor:='Patrick Gonçalves Medeiros';
end;

//------------------------------------------------------------------------------------------------------------
// Função GetConsoleKey                                                                                      =
// Entrada:                                                                                                  =
// Saída:                                                                                                    =
// Sub-Functions: None                                                                                       =
//------------------------------------------------------------------------------------------------------------
Function  GetConsoleKey:ShortString;stdcall;export;
var
  resposta,comando:ShortString;
  f : ShortString;
  x:ShortString;
  i:Integer;
  r:Integer;
  count:Integer;
begin
  Randomize;
  x:='';
  for count :=1 to 16 do
  begin
    i := RandomRange(10,99);
    x := x + IntToStr(i);
  end;
  r :=   RandomRange(1,5);
  comando := '(?F0' + IntToStr(r) + 'E' + x;
  comando := AdicionaCheck(comando);
  resposta := Get('loaGetConsoleKey', comando, 1000);
  if  Length(resposta) = 86 then
  begin
    f :=  IntToStr(r) + x +  copy(resposta, 4,80);
    result:= f;
  end
  else
  begin
    result:= '';
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função FormatBackup                                                                                       =
// Entrada: tx/rx, date, codfuncao, len, data                                                                =
// Saída: arquivo hexa                                                                                       =
// Sub-Functions: None                                                                                       =
//------------------------------------------------------------------------------------------------------------
procedure FormatBackup(fluxo:boolean;datetime:tdatetime;codfuncao:byte;data:string);
var
  a:byte;
  st:string;
  stout,stoutdata:string;
begin
  st:=formatdatetime('hh:mm:ss:zzz',datetime);
  for a:=2 to length(data) do stoutdata:=stoutdata + data[a];
  if fluxo then
    stout:=' -> '
  else
    stout:=' <- ';
  stout:=st + stout + data;
end;

//------------------------------------------------------------------------------------------------------------
// Função TxRxSerial                                                                                         =
// Entrada: tx/rx, date, codfuncao, len, data                                                                =
// Saída: arquivo hexa                                                                                       =
// Sub-Functions: None                                                                                       =
//------------------------------------------------------------------------------------------------------------
function TxRxSerial(comando:string;timeout:cardinal):pchar;stdcall;export;
var
  rta:string;
  //prta:pchar;
  a:integer;
begin
  for a:=1 to length(comando) do
    if comando[a]=')' then
      break;
    comando:=copy(comando,1,a);
    SendText('TxRx',comando);
    rta:=ReceiveText('TxRx',2000);
    result:=pchar(rta);
end;

//------------------------------------------------------------------------------------------------------------
// Procedimento LimpaSerial                                                                                  =
// Entrada:                                                                                                  =
// Saída:                                                                                                    =
// Sub-Functions: None                                                                                       =
//------------------------------------------------------------------------------------------------------------
Procedure LimpaSerial;stdcall; export;
var
  trash:string;
begin
  trash:=Get('LimpaSerial','',1);
end;

//------------------------------------------------------------------------------------------------------------
// Procedimento ReadSerial                                                                                   =
// Entrada: timeout                                                                                          =
// Saída: estrutura Retorno                                                                                  =
// Sub-Functions: None                                                                                       =
//------------------------------------------------------------------------------------------------------------
Function ReadSerial(timeout:integer):pchar;stdcall; export;
var
  st:string;
begin
  if timeout>3000 then
    timeout:=3000;
  st:=Get('ReadSerial','',timeout);
  result:=pchar(st);
end;

//------------------------------------------------------------------------------------------------------------
// Procedimento ReadSocket                                                                                   =
// Entrada: timeout                                                                                          =
// Saída: estrutura Retorno                                                                                  =
// Sub-Functions: None                                                                                       =
//------------------------------------------------------------------------------------------------------------
Function ReadSocket(timeout:cardinal):ShortString;stdcall; export;
begin
  result:=Get('ReadSerial','',timeout);
end;

//------------------------------------------------------------------------------------------------------------
// Procedimento WriteSerial                                                                                  =
// Entrada: Comando a ser escrito na serial                                                                  =
// Saída: Nill                                                                                               =
// Sub-Functions: None                                                                                       =
//------------------------------------------------------------------------------------------------------------
Procedure WriteSerial(comando:string;len:integer);stdcall;export;
begin
  if SendText('WriteSerial',copy(comando,1,len)) then
    sleep(1);
end;

//------------------------------------------------------------------------------------------------------------
// Função EnviaComando                                                                                       =
// Entrada: string de comando,tempo máximo de espera (timeout)                                               =
// Saída: string lida da serial                                                                              =
// Sub-Functions: None                                                                                       =
//------------------------------------------------------------------------------------------------------------
Function EnviaComando(comando:string;timeout:cardinal):ShortString;stdcall; export;
begin
  result:=Get('EnviaComando',comando,timeout);
end;

//------------------------------------------------------------------------------------------------------------
// Função InicializaSerial                                                                                   =
// Entrada: Número da porta a ser aberta                                                                     =
// Saída: resposta se abriu ou não a porta                                                                   =
// Sub-Functions: cvbinario32,bintodec                                                                       =
//------------------------------------------------------------------------------------------------------------
Function InicializaSerial(np:byte): Boolean; stdcall; export;
var
  rta:boolean;
begin
  rta:=OpenSerial(np);
  result:=rta;
end;

//------------------------------------------------------------------------------------------------------------
// Função InicializaATCSerial                                                                                =
// Entrada: Número da porta a ser aberta                                                                     =
// Saída: resposta se abriu ou não a porta                                                                   =
// Sub-Functions: cvbinario32,bintodec                                                                       =
//------------------------------------------------------------------------------------------------------------
Function InicializaATCSerial(np:byte): Boolean; stdcall; export;
var
  rta:boolean;
begin
  rta:=OpenATCSerial(np);
  result:=rta;
end;


//------------------------------------------------------------------------------------------------------------
// Função FOXInicializaSerial                                                                                =
// Entrada: Número da porta a ser aberta                                                                     =
// Saída: resposta se abriu ou não a porta                                                                   =
// Sub-Functions: cvbinario32,bintodec                                                                       =
//------------------------------------------------------------------------------------------------------------
Function FOX_InicializaSerial(np:integer):integer; stdcall; export;
var
  rta:boolean;
begin
  rta := OpenSerial(np);
  if rta then
    result:=1
  else
    result:=0;
end;

//------------------------------------------------------------------------------------------------------------
// Função InicializaSocket                                                                                   =
// Entrada: Número do IP a ser aberto                                                                        =
// Saída: resposta se abriu ou não a porta                                                                   =
// Sub-Functions: cvbinario32,bintodec                                                                       =
//------------------------------------------------------------------------------------------------------------
Function InicializaSocket(ip:pchar):Boolean; stdcall; export;
//var
//  st:string;
begin
  result := OpenSocket(ip);
//  ShowMessage(BoolToStr(result));
  if Result then
    result := true
  else
    result := false;
end;

//------------------------------------------------------------------------------------------------------------
// Função InicializaSocket2                                                                                  =
// Entrada: Número do IP e porta a serem abertos                                                             =
// Saída: resposta se abriu ou não a porta                                                                   =
// Sub-Functions: cvbinario32,bintodec                                                                       =
//------------------------------------------------------------------------------------------------------------
Function InicializaSocket2(ip:pchar;porta:integer):Boolean; stdcall; export;
//var
  //st:string;
begin
  try
    result := OpenSocket2(ip,porta);
  except
    result := false;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função ConsultaPorta                                                                                      =
// Entrada: Nenhuma                                                                                          =
// Saída: Número da porta que está configurada na função InicializaSocket                                    =
//------------------------------------------------------------------------------------------------------------
Function ConsultaPorta():Integer; stdcall; export;
begin
    result := 2001;
end;
//------------------------------------------------------------------------------------------------------------
// Função InicializaATCSocket                                                                                =
// Entrada: Número do IP e porta a serem abertos                                                             =
// Saída: resposta se abriu ou naum a porta                                                                  =
// Sub-Functions: cvbinario32,bintodec                                                                       =
//------------------------------------------------------------------------------------------------------------
Function InicializaATCSocket(ip:pchar;porta:integer):Boolean; stdcall; export;
//var
  //st:string;
begin
  try
    result:=OpenSocketATC(ip,porta);
  except
    result:=false;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função InicializaSocket3                                                                                  =
// Entrada: Número do IP a ser aberto                                                                        =
// Saída: resposta se abriu ou não a porta                                                                   =
// Sub-Functions: cvbinario32,bintodec                                                                       =
//------------------------------------------------------------------------------------------------------------
Function InicializaSocket3(ip:pchar):Boolean; stdcall; export;
var st:string;
    cont:byte;
begin
  try
    cont:=1;
    st:='';
    while ip[cont]<>'.' do
    begin
      st:=st+ip[cont];
      inc(cont);
    end;
    result:=OpenSocket(ip);
  except
    result:=false;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função InicializaLogSerial                                                                                =
// Entrada: Número da porta / arquivo a ser gerado                                                           =
// Saída: Boolean se abriu ou não a porta                                                                    =
// Sub-Functions: None                                                                                       =
//------------------------------------------------------------------------------------------------------------
Function InicializaLogSerial(np:byte;LogFile:string):boolean; stdcall; export;
begin
  if CreateLogFile(LogFile) then
  begin
    if InicializaSerial(np) then
      result:=true
    else
      result:=false;
  end
  else
    result:=false;
end;

//------------------------------------------------------------------------------------------------------------
// Função FormataFloat                                                                                       =
// Entrada: valor:float / caracteres,casas decimais:byte                                                     =
// Saída: String de tam. variável conf. a entrada caracteres                                                 =
// Sub-Functions: None                                                                                       =
//------------------------------------------------------------------------------------------------------------
Function FormataFloat(val:real;caracteres,decimais:byte):string;
var
  STVal,pa,pb:string;
  a:byte;
  fl_dec:boolean;
  saida:string[4];
begin
  pa := '';
  pb := '';
  fl_dec := false;
  STVal := floattostr(val);
  for a := 1 to length(STVal) do
  begin
    if STVal[a] = ',' then
      fl_dec := true;
    if fl_dec = false then
      pa := pa + STVal[a]
    else if STVal[a] <> ',' then
            pb := pb + STVal[a];
    end;
  for a := length(pb)+1 to decimais do pb := pb + '0';
  for a := length(pa)+1 to caracteres-decimais do pa := '0' + pa;
  saida := pa + pb;
  Result := saida;
end;

//------------------------------------------------------------------------------------------------------------
// Função FormataFloatToExtendedPrice                                                                        =
// Entrada: valor:float / caracteres,casas decimais:byte                                                     =
// Saída: String de tam. variável conf. a entrada caracteres                                                 =
// Sub-Functions: None                                                                                       =
//------------------------------------------------------------------------------------------------------------
Function FormataFloatToExtendedPrice(val:real;caracteres,decimais:byte):string;
var
  STVal,pa,pb:string;
  a:byte;
  fl_dec:boolean;
  saida:string[6];
begin
  pa := '';
  pb := '';
  fl_dec := false;
  STVal := floattostr(val);
  for a := 1 to length(STVal) do
  begin
    if STVal[a] = ',' then
      fl_dec := true;
    if fl_dec = false then
      pa := pa + STVal[a]
    else if STVal[a] <> ',' then
            pb := pb + STVal[a];
    end;
  for a := length(pb)+1 to decimais do pb := pb + '0';
  for a := length(pa)+1 to caracteres-decimais do pa := '0' + pa;
  saida := pa + pb;
  Result := saida;
end;
//------------------------------------------------------------------------------------------------------------
// Função AdicionaCheck                                                                                      =
// Entrada: String a ser adicionado o check                                                                  =
// Saída: String com o check ja adicionado                                                                   =
// Sub-Functions: None                                                                                       =
//------------------------------------------------------------------------------------------------------------
Function AdicionaCheck(STin:string):string;
var
  a,check:byte;
  i :integer;
begin
  check:=0;
  for a:=2 to length(STin) do
  begin
    i :=  ord(STin[a]);
    check:=check + i ;
  end;
  result:=STin + inttohex(check,2) + ')';
end;

//------------------------------------------------------------------------------------------------------------
// Função ConsultaEncerrante                                                                                 =
// Entrada: Nº do bico                                                                                       =
// Saída: Estrutura Encerrante (bico:string[2],valor:real)                                                   =
// Sub-Functions: None                                                                                       =
// Comando : (&T04L2A)                                                                                       =
// Resposta: (TL0408074692A8)                                                                                =
// Comando : (&T04l4A)                                                                                       =
// Resposta: (Tl04000807469228)                                                                              =
//------------------------------------------------------------------------------------------------------------
Function ConsultaEncerrante(modo:char; bico:string):Encerrante;stdcall; export;
var
  comando,resposta:string[50];
  Total:encerrante;
  str: string ;
begin
  str := bico;
  //bico:=copy(bico,1,2);
  Total.Bico:='00';
  Total.Valor:=0;
  //messagedlg(string( modo ) + ' = ' +  bico ,mtinformation,[mbok],0);
  //messagedlg('>>' + str,mtinformation,[mbok],0);
  comando:=AdicionaCheck('(&T' + bico + modo);
  resposta:=Get('ConsultaEncerrante',comando,3000);
  if resposta<>'PORTA NAO ABERTA' then
  begin
    Total.Bico:=copy(resposta,4,2);
    if length(resposta)=16 then
      Total.Valor:= strtofloat(copy(resposta,6,6) + ',' + copy(resposta,12,2))
    else if length(resposta)=18 then
      Total.Valor:= strtofloat(copy(resposta,6,8) + ',' + copy(resposta,14,2));
  end
  else if resposta='DESCONECTADO' then
        begin
          total.Bico:='00';
          total.Valor:=-2;
        end
      else
      begin
          total.bico:='00';
          total.Valor:=-1;
      end;
  result:=Total;
end;

//------------------------------------------------------------------------------------------------------------
// Função HRSGetSalePAF                                                                                      =
// Entrada: nenhum                                                                                           =
// Saída: Retorna o abastecimento na memória com 8 dígitos                                                   =
// Sub-Functions: none                                                                                       =
//------------------------------------------------------------------------------------------------------------
Function HRSGetSalePAF():PChar; stdcall; export;
var
  resposta:string;
  comando:string[12];
begin
  try
    comando:='>?000402A1D7';
    resposta:=Get('HRSGetSalePAF',comando,3000);
    if(length(resposta)=127) then
      begin
        result := pchar(resposta + #0);
      end
    else
    begin
      result := pchar('(0)' + #0);
    end;
  except
    result := pchar('ERROR' + #0);
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função HRSSaveTAG                                                                                         =
// Entrada: código da TAG e permissão                                                                        =
// Saída: Retorna a posição do identificador em memória ou '0'                                               =
// Sub-Functions: none                                                                                       =
//------------------------------------------------------------------------------------------------------------
Function HRSSaveTAG(tag:pchar;level:integer):integer; stdcall; export;
var
  comando,resposta:string;
  stLevel:string[2];
begin
  // >?00140D12345678123456780424
  stLevel:=inttostr(level);
  if length(stLevel)<2 then
    stLevel:='0'+stLevel;
  comando:=HRSMontaComando(13, tag + stLevel);
  resposta:=Get('HRSSaveTag',comando,1000);
  Comando := ParseRtaCode(resposta, false);
  if (Comando = 'COMANDO OK') then
    result:=strtoint(copy(resposta,9,6))
  else
    result:=0;
end;


//------------------------------------------------------------------------------------------------------------
// Função HRSReadTAg                                                                                         =
// Entrada: indice na memória, código da TAG e permissão                                                     =
// Saída: Retorna a a linha solicitada ou '0'                                                                =
// Sub-Functions: none                                                                                       =
// >!00352704000001;B3CF89D2D5E61939;27: CARD ATTENDANT 1 L  ;D4                                             =
// 1234567890123456789012345678901234567890123456789012345678901234567890                                    =
//          1         2         3         4         5         6                                              =
//------------------------------------------------------------------------------------------------------------
Function HRSReadTAG(indice:integer;var tag:ansistring; var level:integer):integer; stdcall; export;
var
  comando,resposta:string;
  //stLevel:string[2];
  stCount:string[6];
begin
  stcount := inttostr(indice);
  while length(stcount) < 6 do
    stcount := '0' + stcount;
    comando := HRSMontaComando(39, '04' + stcount);
    //messagedlg(comando,mterror,[mbok],0);
    resposta:= Get('HRSReadTag',comando,2000);
    Comando := ParseRtaCode(resposta, false);
    if (Comando = 'COMANDO OK') then
    begin
      tag:=copy(resposta,18,16);
      level:=strtoint(copy(resposta,35,2));
      // messagedlg(level,mterror,[mbok],0);
      result:=strtoint(copy(resposta,9,6));
    end
    else
    result:=0;
end;

{
 -------------------------------------------------------------------------------------------------------------------------
 >!00352704000001;9999999999999999;27: CARD ATTENDANT 1 L  ;B5
 1234567890123456789012345678901234567890123456789012345678901234567890
 1         2         3         4         5         6
 >!00020245
function readMemoryTag(position: integer): string;
var
  stcount, resposta, comando: string;
begin
  stcount := inttostr(position);
  while length(stcount) < 6 do
    stcount := '0' + stcount;
  comando := montaComando(39, '04' + stcount);
  resposta := form1.writeCommand(comando, 1000);
  if resposta = '>!00020245' then
    result := '0'
  else
  begin
    if length(resposta) > 34 then
    begin
      if (resposta[17] = ';') and (resposta[34] = ';') and (copy(resposta, 11, 6) = stcount) then
        result := copy(resposta, 18, 16)
      else
        result := '-1';
    end;
  end;

end;
}

//------------------------------------------------------------------------------------------------------------
// Função HRSReadTAg                                                                                         =
// Entrada: indice na memória, código da TAG e permissão                                                     =
// Saída: Retorna a a linha solicitada ou '0'                                                                =
// Sub-Functions: none                                                                                       =
// >!00352704000001;B3CF89D2D5E61939;27: CARD ATTENDANT 1 L  ;D4                                             =
// 1234567890123456789012345678901234567890123456789012345678901234567890                                    =
//          1         2         3         4         5         6                                              =
//------------------------------------------------------------------------------------------------------------
Function parseDate(hora,minuto,dia,mes,ano:byte):boolean;
//var
  //teste:tdatetime;
begin
  try
    //teste:=encodedatetime(ano,mes,dia,hora,minuto,0,0);
    result:=true;
  except
    result:=false;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função HRSReadTAg                                                                                         =
// Entrada: indice na memória, código da TAG e permissão                                                     =
// Saída: Retorna a a linha solicitada ou '0'                                                                =
// Sub-Functions: none                                                                                       =
// >!00352704000001;B3CF89D2D5E61939;27: CARD ATTENDANT 1 L  ;D4                                             =
// 1234567890123456789012345678901234567890123456789012345678901234567890                                    =
//          1         2         3         4         5         6                                              =
//------------------------------------------------------------------------------------------------------------
function getclock:string; stdcall;export;
var
    str : string;
    resposta:string;
    comando:string;
begin
   comando := HRSMontaComando(11,'');
   resposta := get('getclock',comando,1000);
   //messagedlg(resposta,mterror,[mbok],0);
   if(resposta <> 'SEM RESPOSTA') then
   begin
      str:= copy(resposta,13,2)+ '/'+copy(resposta,11,2) +'/' +copy(resposta,9,2) + ' '+ copy(resposta,17,2)+ ':' + copy(resposta,19,2);
      result := str ;
      //messagedlg(str,mterror,[mbok],0);
   end
   else
   begin
       resposta := get('getclock','(&R)',1000);
       if(copy(resposta,1,4) = '(REL') then
       begin
           str := copy(resposta,15,8) + ' ' + copy(resposta,6,5);
           result := str;
           //messagedlg(str,mterror,[mbok],0);
       end;
   end;


end;


//------------------------------------------------------------------------------------------------------------
// Função LeSTEncerrante                                                                                     -
// Entrada: Nº do bico, tipo do pedido                                                                       -
// Saída: String com o valor                                                                                 -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function GetEncerranteVolume(bicoInt:byte):ShortString;stdcall; export;
var
  comando,resposta,rt:string;
  bico:string;
begin
  bico:=inttohex(bicoInt,2);
  comando:=AdicionaCheck('(&T' + bico + 'L');
  resposta:=Get('LeSTEncerrante',comando,2500);
  if length(resposta)=16 then
    rt:=copy(resposta,6,6) + ',' + copy(resposta,12,2)
  else if length(resposta)=18 then
    rt:=copy(resposta,6,8) + ',' + copy(resposta,14,2)
  else
  rt:='FALHA';
  result:=rt;
end;


//------------------------------------------------------------------------------------------------------------
// Função LeSTEncerrante                                                                                     -
// Entrada: Nº do bico, tipo do pedido                                                                       -
// Saída: String com o valor                                                                                 -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function GetEncerranteValor(bicoInt:byte):ShortString;stdcall; export;
var comando,resposta,rt:string;
    bico:string;
begin
bico:=inttohex(bicoInt,2);
comando:=AdicionaCheck('(&T' + bico + '$');
resposta:=Get('LeSTEncerrante',comando,2500);
if length(resposta)=16 then
  rt:=copy(resposta,6,6) + ',' + copy(resposta,12,2)
else if length(resposta)=18 then
  rt:=copy(resposta,6,8) + ',' + copy(resposta,14,2)
else
  rt:='FALHA';
result:=rt;
end;

//------------------------------------------------------------------------------------------------------------
// Função ListaNegra                                                                                         -
// Entrada: TAG, modo (b=bloqueia;l=libera; c=limpa lista                                                    -
// Comando: (?M99biiiiiiiiiiiiiiiiKK)                                                                        -
// resposta: (M99) / (?F)                                                                                    -
// Saída: String com o valor                                                                                 -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------

Function SetBlackList(modo:char;TAG:string):boolean;stdcall; export;
var comando,rta:string;
begin
try
if ((modo='l') or (modo='b') or (modo='c')) and (length(TAG)=16) then
  begin
  comando:=AdicionaCheck('(&M99' + modo + TAG);
  rta:=Get('SetBlackList',comando,2000);
  if length(rta)>=4 then
    result:=rta='(M99)'
  else
    result:=false;
  end;
except
  result:=false;
end;
end;



Function PushBlackList(tag:pchar):boolean;stdcall;export;
var comando,rta:string;
begin
  try
    if(length(tag)=16) then
    begin
      comando := AdicionaCheck('(&M99b' + tag);
      rta:=Get('PushBlackList',comando,2000);
      if(length(rta)>=4) then
        result:= rta='(M99)'
      else
        result:=false;
    end
    else
    begin
      result:=false;
    end;
  except
    result:= false;
  end;
end;


Function PopBlackList(tag:pchar):boolean;stdcall;export;
var comando,rta:string;
begin
try
    if(length(tag)=16) then
    begin
      comando := AdicionaCheck('(&M99l' + tag);
      rta:=Get('PopBlackList',comando,2000);
      if(length(rta)>=4) then
        result:= rta='(M99)'
      else
        result:=false;
    end
    else
    begin
      result:=false;
    end;
except
  result:= false;
end;
end;



Function ClearBlackList():boolean;stdcall; export;
var comando,rta:string;
begin
  try
    comando:=AdicionaCheck('(&M99c');
    rta:=Get('ClearBlackList',comando,2000);
    if length(rta)>=4 then
      result:=rta='(M99)'
    else
      result:=false;
  except
    result:=false;
  end;
end;


//------------------------------------------------------------------------------------------------------------
// Função LeSTEncerrante                                                                                     -
// Entrada: Nº do bico, tipo do pedido                                                                       -
// Saída: String com o valor                                                                                 -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeSTEncerrante(modo:string;bico:string):ShortString;stdcall; export;
var comando,resposta,rt:string;
begin
  bico:=copy(bico,1,2);
  comando:=AdicionaCheck('(&T' + bico + modo);
 // messagedlg(comando,mterror,[mbok],0);
  resposta:=Get('LeSTEncerrante',comando,2500);
  //messagedlg(comando,mterror,[mbok],0);

  if length(resposta)=16 then
    rt:=copy(resposta,6,6) + ',' + copy(resposta,12,2)
  else if length(resposta)=18 then
    rt:=copy(resposta,6,8) + ',' + copy(resposta,14,2)
  else
    rt:='FALHA';
  result:=rt;
end;


Function LeEncerrante2(modo:pchar;bico:shortstring ):shortstring;stdcall; export;
var   comando :string;
      resposta: string;
begin
      //messagedlg('MODO : ' + modo + ' BICO : ' + bico ,mterror,[mbok],0);
  if Length(modo) = 1 then
  begin
        comando := AdicionaCheck('(&T' + bico  + modo);
        //messagedlg(comando,mterror,[mbok],0);
        resposta:=Get('LeSTEncerrante',comando,3000);
       // messagedlg(resposta,mterror,[mbok],0);
        result := resposta;
  end;
end;


//------------------------------------------------------------------------------------------------------------
// Função ComparaCheck                                                                                       -
// Entrada: String de rta da placa                                                                           -
// Saída: Boolean                                                                                            -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function ComparaCheck(st:string):boolean;
var a,posicao:byte;
    check:byte;
    checksum:string[2];
begin
check:=0;
result:=false;
if (st='(0)') or (st[length(st)]<>')') then exit;
checksum:=copy(st,length(st)-2,2);
if length(st)=34 then
    begin
    posicao:=2;
    while posicao<=31 do
        begin
        check:=check + strtoint('$' + copy(st,posicao,2));
        posicao:=posicao+2;
        end;
    end
else for a:=2 to length(st)-3 do check:=check + ord(st[a]);
if checksum=inttohex(check,2) then result:=true else result:=false;
end;


//--------------------------------------------------------------------------------------------------------
Function LeVirgula(code:string):virgula;
var code_pass:virgula;
    par1,par2:char;
begin
par1:=code[1];
par2:=code[2];
code_pass.ppu:=4 - strtoint(par1);
if par2='A' then
    begin
    code_pass.ptotal:=4;
    code_pass.litragem:=4;
    end
else if par2='E' then
    begin
    code_pass.ptotal:=4;
    code_pass.litragem:=3;
    end
else if par2='F' then
    begin
    code_pass.ptotal:=3;
    code_pass.litragem:=3;
    end
else if par2='B' then
    begin
    code_pass.ptotal:=3;
    code_pass.litragem:=4;
    end;
if code_pass.ptotal>4 then code_pass.ptotal:=4;
if code_pass.ppu>3 then code_pass.ppu:=3;
if code_pass.litragem>5 then code_pass.litragem:=5;
result:=code_pass;
end;


//------------------------------------------------------------------------------------------------------------
// Função Incrementa                                                                                         -
// Entrada: Nill                                                                                             -
// Saída: Nill                                                                                               -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure Incrementa;stdcall; export;
begin
Get('Incrementa','(&I)',1);

//messagedlg('Incrementa',mtinformation,[mbok],0);
end;


Function FormataTempo(StTempo:string):string;
var tpabast,hora,minuto,segundos:integer;
    STHora,STMinuto,STSegundo:string[2];
begin
  hora:=0;minuto:=0;segundos:=0;
  tpabast:=strtoint('$' + StTempo);
  if tpabast>3600 then
    begin
      hora:=trunc(tpabast/3600);
      tpabast:=(tpabast-(hora*3600));
    end;
    if tpabast>=60 then
        begin
          minuto:=trunc(tpabast/60);
          segundos:=(tpabast-(minuto*60));
        end;
    if tpabast<60 then segundos:=tpabast;
    STHora:=inttostr(hora);
    STMinuto:=inttostr(minuto);
    STSegundo:=inttostr(segundos);
    if length(STHora)<2 then STHora:='0' + STHora;
    if length(STMinuto)<2 then STMinuto:='0' + STMinuto;
    if length(STSegundo)<2 then STSegundo:='0' + STSegundo;
    result:= STHora + ':' + STMinuto + ':' + STSegundo;
end;


//------------------------------------------------------------------------------------------------------------
// Função StrtoAbast                                                                                         -
// Entrada: String de abastecimento                                                                          -
// Saída: Estrutura Abast                                                                                    -
// Sub-Functions: LeVirgula                                                                                  -
// (ATTTTTTLLLLLLPPPPVVCCCCBBDDHHMMNNRRRREEEEEEEEEESSXXXXXXXXXXXXXXXXZZZZYYKK)                               -
// (@TTTTTTLLLLLLPPPPVVCCCCBBDDHHMMNNRRRREEEEEEEEEEssIIIIIIIIIIIIIIIIiiiiiiiiiiiiiiiiSSKK)                   -
// 123456789012345678901234567890123456789012345678901234567890123456789012345678901234567                   -
// 0        1         2         3         4         5         6         7         8
//------------------------------------------------------------------------------------------------------------
Function StrToAbastFid2(SAbast:string):abastFid2;
var virg:virgula;
    abastecimento: abastFid2;
    a,inicio,fim: byte;
begin
  inicio:=0;fim:=0;
  for a:=1 to length(SAbast) do
      begin
        if SAbast[a]='(' then inicio:=a else
        if SAbast[a]=')' then fim:=a+1;
      end;
  if (SAbast[2]='A') or (SAbast[2]='@') then
    SAbast:='(' + copy(SAbast,3,fim-inicio)
  else
    SAbast:='(' + copy(SAbast,2,fim-inicio);
    virg:=LeVirgula(copy(SAbast,18,2));
    abastecimento.st_full:=SAbast;
    abastecimento.value:=true;
    abastecimento.canal:=copy(SAbast,24,2);
    abastecimento.total_litros:=strtofloat(copy(SAbast,8,virg.litragem) + ',' + copy(SAbast,8+virg.litragem,6-virg.litragem));
    abastecimento.PU:=strtofloat(copy(SAbast,14,virg.ppu) + ',' + copy(SAbast,14+virg.ppu,4-virg.ppu));
    abastecimento.total_dinheiro:=strtofloat(copy(SAbast,2,virg.ptotal) + ',' + copy(SAbast,2+virg.ptotal,6-virg.ptotal));
    abastecimento.data:=copy(SAbast,26,2) + '/' + formatdatetime('mm/yyyy',now);
    abastecimento.hora:=copy(SAbast,28,2) + ':' + copy(SAbast,30,2);
    abastecimento.tempo:=FormataTempo(copy(SAbast,20,4));
    abastecimento.tag:=copy(SAbast,50,16);
    abastecimento.tag2:=copy(SAbast,66,16);
    abastecimento.checksum:=ComparaCheck(SAbast);
    abastecimento.registro:=strtoint(copy(SAbast,34,4));
    abastecimento.encerrante:=strtofloat(copy(SAbast,38,8) + ',' + copy(SAbast,46,2));
    abastecimento.data:=copy(SAbast,26,2) + '/' + copy(SAbast,32,2) + '/' + formatdatetime('yyyy',now);
    abastecimento.integridade:=copy(SAbast,48,2)='00';
    result:=abastecimento;
end;


//------------------------------------------------------------------------------------------------------------
// Função StrtoAbastPAF1                                                                                     -
// Entrada: String de abastecimento                                                                          -
// Saída: Estrutura Abast                                                                                    -
//(a2 3 00000886 008000 002526 3167 3A 0088 88 2809151013 001384 0038903833 0038901307 09 02 03 00D0D0D0 B3CF6C81BF34BF6B FFFFFFFFFFFFFFFF 00 E3)
//(a2 G 00005118 000400 003242 1234 3E 0007 04 0511470711 000877 0000555351 0000555026 12 34 56 00987654 0000000000000000 0000000000000000 00 81)
//(a2 $ SSSSSSSS TTTTTT LLLLLL PPPP VV CCCC BB DDHHMMNNAA RRRRRR ffffffffff iiiiiiiiii bb cc tt vvvvvvvv IIIIIIIIIIIIIIII JJJJJJJJJJJJJJJJ nn KK)
//123 4 56789012 345678 901234 5678 90 1234 56 7890123456 789012 3456789012 3456789012 34 56 78 90123456 7890123456789012 3456789012345678 90 123
//(a2 G 00000001 000300 00125024003A00080415164501080000380000229645000022839500000000000000B3CF6CA5B713C440FFFFFFFFFFFFFFFF0034)
//0          1           2           3            4          5          6          7             8          9        10         11         12
//------------------------------------------------------------------------------------------------------------
Function StrToAbastPAF1(SAbast:string):abastPAF1;
var virg:virgula;
    abastecimento: abastPAF1;
begin
  virg:=LeVirgula(copy(SAbast,29,2));
  with abastecimento do
    begin
      st_full:=SAbast;
      value:=true;
      tipocbc:=SAbast[4];
      total_dinheiro:=strtofloat(copy(SAbast,13,4) + ',' + copy(SAbast,17,2));
      total_litros:=strtofloat(copy(SAbast,19,virg.litragem) + ',' + copy(SAbast,19+virg.litragem,6-virg.litragem));
      PU:=strtofloat(copy(SAbast,25,virg.ppu) + ',' + copy(SAbast,25+virg.ppu,4-virg.ppu));
      tempo:=FormataTempo(copy(SAbast,31,4));
      codbico:=copy(SAbast,35,2);
      data:=copy(SAbast,37,2)+'/'+copy(SAbast,43,2)+'/20'+copy(SAbast,45,2);
      hora:=copy(SAbast,39,2) + ':' + copy(SAbast,41,2);
      registro:=strtoint(copy(SAbast,47,6));
      encerranteF:=strtofloat(copy(SAbast,53,8) + ',' + copy(SAbast,61,2));
      encerranteI:=strtofloat(copy(SAbast,63,8) + ',' + copy(SAbast,71,2));


      numbico:=strtoint(copy(SAbast,73,2));
      codcombustivel:=strtoint(copy(SAbast,75,2));
      numtanque:=strtoint(copy(SAbast,77,2));
      //voltanque:=strtoint(copy(SAbast,79,8));
      voltanque:=0;
      tag1:=copy(SAbast,87,16);
      tag2:=copy(SAbast,103,16);
      integridade:=copy(SAbast,119,2)='00';
      checksum:=ComparaCheck(SAbast);
    end;
  result:=abastecimento;
end;


//------------------------------------------------------------------------------------------------------------
// Função StrtoAbastPAF1                                                                                     -
// Entrada: String de abastecimento                                                                          -
// Saída: Estrutura Abast                                                                                    -
//(a2 G 00005118 000400 003242 1234 3E 0007 04 0511470711 000877 0000555351 0000555026 12 34 56 00987654 0000000000000000 0000000000000000 00 81)
//(a2 $ SSSSSSSS TTTTTT LLLLLL PPPP VV CCCC BB DDHHMMNNAA RRRRRR ffffffffff iiiiiiiiii bb cc tt vvvvvvvv IIIIIIIIIIIIIIII JJJJJJJJJJJJJJJJ nn KK)
//123 4 56789012 345678 901234 5678 90 1234 56 7890123456 789012 3456789012 3456789012 34 56 78 90123456 7890123456789012 3456789012345678 90 123
//(a2 G 00000001 000300 00125024003A00080415164501080000380000229645000022839500000000000000B3CF6CA5B713C440FFFFFFFFFFFFFFFF0034)
//0          1           2           3            4          5          6          7             8          9        10         11         12
//------------------------------------------------------------------------------------------------------------
Function StrToAbastPAF1XE(SAbast:widestring):abastPAF1XE;
var virg:virgula;
    abastecimento: abastPAF1XE;
begin
  virg:=LeVirgula(copy(SAbast,29,2));
  with abastecimento do
    begin
      st_full:=SAbast;
      value:=true;
      tipocbc:=SAbast[4];
      total_dinheiro:=strtofloat(copy(SAbast,13,4) + ',' + copy(SAbast,17,2));
      total_litros:=strtofloat(copy(SAbast,19,virg.litragem) + ',' + copy(SAbast,19+virg.litragem,6-virg.litragem));
      PU:=strtofloat(copy(SAbast,25,virg.ppu) + ',' + copy(SAbast,25+virg.ppu,4-virg.ppu));
      tempo:=FormataTempo(copy(SAbast,31,4));
      codbico:=copy(SAbast,35,2);
      data:=copy(SAbast,37,2)+'/'+copy(SAbast,43,2)+'/20'+copy(SAbast,45,2);
      hora:=copy(SAbast,39,2) + ':' + copy(SAbast,41,2);
      registro:=strtoint(copy(SAbast,47,6));
      encerranteF:=strtofloat(copy(SAbast,53,8) + ',' + copy(SAbast,61,2));
      encerranteI:=strtofloat(copy(SAbast,63,8) + ',' + copy(SAbast,71,2));
      numbico:=strtoint(copy(SAbast,73,2));
      codcombustivel:=strtoint(copy(SAbast,75,2));
      numtanque:=strtoint(copy(SAbast,77,2));
      voltanque:=strtoint(copy(SAbast,79,8));
      tag1:=copy(SAbast,87,16);
      tag2:=copy(SAbast,103,16);
      integridade:=copy(SAbast,119,2)='00';
      checksum:=ComparaCheck(SAbast);
    end;
  result:=abastecimento;
end;


//------------------------------------------------------------------------------------------------------------
// Função StrtoAbastPAF2                                                                                   -
// Entrada: String de abastecimento                                                                          -
// Saída: Estrutura Abast                                                                                    -
//(a2 G 00005118 000400 003242 1234 3E 0007 04 0511470711 000877 0000555351 0000555026 12 34 56 00987654 0000000000000000 0000000000000000 00 81)

//(a2 3 00002419 000111 000413 2690 3E 1230 48 1415561213 000030 0035006482 1954353670 08 01 01 00FF75F80000000000000000000000000000000000A3)';
//(a2 $ SSSSSSSS TTTTTT LLLLLL PPPP VV CCCC BB DDHHMMNNAA RRRRRR ffffffffff iiiiiiiiii bb cc tt vvvvvvvv IIIIIIIIIIIIIIII JJJJJJJJJJJJJJJJ nn KK)
//123 4 56789012 345678 901234 5678 90 1234 56 7890123456 789012 3456789012 3456789012 34 56 78 90123456 7890123456789012 3456789012345678 90 123
//0          1           2           3            4          5          6          7             8          9        10         11         12
//------------------------------------------------------------------------------------------------------------
Function StrToAbastPAF2(SAbast:string):abastPAF2;
var virg:virgula;
    abastecimento: abastPAF2;
begin
  virg:=LeVirgula(copy(SAbast,29,2));
  with abastecimento do
    begin
      st_full := SAbast;
      value := true;
      tipocbc := SAbast[4];
      total_dinheiro := strtofloat(copy(SAbast,13,4) + ',' + copy(SAbast,17,2));
      total_litros := strtofloat(copy(SAbast,19,virg.litragem) + ',' + copy(SAbast,19+virg.litragem,6-virg.litragem));
      PU := strtofloat(copy(SAbast,25,virg.ppu) + ',' + copy(SAbast,25+virg.ppu,4-virg.ppu));
      tempo := strtoint('$' + copy(SAbast,31,4));
      codbico := copy(SAbast,35,2);
      abastecimento.datetime := encodedate(strtoint(copy(SAbast,45,2))+2000,strtoint(copy(SAbast,43,2)),strtoint(copy(SAbast,37,2)));
      abastecimento.datetime := abastecimento.datetime + encodetime(strtoint(copy(SAbast,39,2)),strtoint(copy(SAbast,41,2)),0,0);
      registro := strtoint(copy(SAbast,47,6));
      encerranteF := strtofloat(copy(SAbast,53,8) + ',' + copy(SAbast,61,2));
      encerranteI := strtofloat(copy(SAbast,63,8) + ',' + copy(SAbast,71,2));
      numbico := strtoint(copy(SAbast,73,2));
      codcombustivel := strtoint(copy(SAbast,75,2));
      numtanque := strtoint(copy(SAbast,77,2));
      try
        voltanque := strtoint(copy(SAbast,79,8));
      except
        voltanque := 0;
      end;
      tag1:=copy(SAbast,87,16);
      tag2:=copy(SAbast,103,16);
      integridade:=copy(SAbast,119,2)='00';
      checksum:=ComparaCheck(SAbast);
    end;
  result:=abastecimento;
end;
//------------------------------------------------------------------------------------------------------------
function StrToCobAbastId(sAbast:string):CobAbastId;
var
  comma: Virgula;
  supply: CobAbastId;
begin
  comma := LeVirgula(copy(sAbast,29,2));
  with supply do
  begin
    st_full := sAbast;
    value := '1';
    habilitacao := sAbast[4];
    total_dinheiro := copy(sAbast,13,6);
    total_litros := copy(sAbast,19,6);
    PU := copy(sAbast,25,4);
    tempo := formatatempo(copy(sAbast,31,4));
    canal := copy(sAbast,35,2);
    data := copy(sAbast,37,2) + '/' + copy(sAbast,43,2) + '/20' + copy(sAbast,45,2);
    hora := copy(sAbast,39,2) + ':' + copy(sAbast,41,2);
    registro := copy(sAbast,47,4);
    encerrante := copy(sAbast,53,10);
    encerrante_inicial := Copy(sAbast,63,10);
    bico_pista := Copy(sAbast,73,2);
    tipo_combustivel := copy(sAbast,75,2);
    numero_tanque := Copy(sAbast,77,2);
    try
      volume_tanque := Copy(sAbast,79,8);
    except
      volume_tanque := '0';
    end;
    Tag := copy(sAbast,87,16);
    Tag2 := copy(sAbast,103,16);
    integridade := sAbast[120];
    if ComparaCheck(sAbast)=true then checksum:='1' else checksum:='0';
  end;
  result := supply;
end;
//------------------------------------------------------------------------------------------------------------
function StrToMemoryPointers(SPointers:string):MemoryPointers;
var
  pointers: MemoryPointers;
begin
  with pointers do
  begin
    writePointer := Copy(SPointers,6,4);
    readPointer := Copy(SPointers,10,4);
  end;
  Result := pointers;
end;
//------------------------------------------------------------------------------------------------------------

Function StrToAbastTWC(SAbast:string):abastTWC;
var virg:virgula;
    abastecimento: abastTWC;
begin
  virg:=LeVirgula(copy(SAbast,29,2));
  with abastecimento do
    begin
      st_full:=SAbast;
      value:=true;
      tipocbc:=SAbast[4];
      total_dinheiro:=strtofloat(copy(SAbast,13,4) + ',' + copy(SAbast,17,2));
      total_litros:=strtofloat(copy(SAbast,19,virg.litragem) + ',' + copy(SAbast,19+virg.litragem,6-virg.litragem));
      PU:=strtofloat(copy(SAbast,25,virg.ppu) + ',' + copy(SAbast,25+virg.ppu,4-virg.ppu));
      tempo:=FormataTempo(copy(SAbast,31,4));
      codbico:=copy(SAbast,35,2);
      abastecimento.data:=copy(SAbast,37,2) + '/' + formatdatetime('mm/yyyy',now);
      abastecimento.hora:=copy(SAbast,39,2) + ':' + copy(SAbast,41,2);

      registro:=strtoint(copy(SAbast,47,6));
      encerranteF:=strtofloat(copy(SAbast,53,8) + ',' + copy(SAbast,61,2));
      encerranteI:=strtofloat(copy(SAbast,63,8) + ',' + copy(SAbast,71,2));
      numbico:=strtoint(copy(SAbast,73,2));
      codcombustivel:=strtoint(copy(SAbast,75,2));
      numtanque:=strtoint(copy(SAbast,77,2));
      try
        voltanque:=strtoint(copy(SAbast,79,8));
      except
        voltanque:=0;
      end;
      tag1:=copy(SAbast,87,16);
      tag2:=copy(SAbast,103,16);
      integridade:=copy(SAbast,119,2)='00';
      checksum:=ComparaCheck(SAbast);
    end;
  result:=abastecimento;
end;


//------------------------------------------------------------------------------------------------------------
// Função StrtoAbast                                                                                         -
// Entrada: String de abastecimento                                                                          -
// Saída: Estrutura Abast                                                                                    -
// Sub-Functions: LeVirgula                                                                                  -
// (ATTTTTTLLLLLLPPPPVVCCCCBBDDHHMMNNRRRREEEEEEEEEESSXXXXXXXXXXXXXXXXZZZZYYKK)                               -
//------------------------------------------------------------------------------------------------------------
Function StrToAbastFid(SAbast:string):abastFid;
  Function LeVirgula(code:string):virgula;
  var code_pass:virgula;
        par1,par2:char;
    begin
      par1:=code[1];
      par2:=code[2];
      code_pass.ppu:=4 - strtoint(par1);
      if par2='A' then
          begin
          code_pass.ptotal:=4;
          code_pass.litragem:=4;
          end
      else if par2='E' then
          begin
          code_pass.ptotal:=4;
          code_pass.litragem:=3;
          end
      else if par2='F' then
          begin
          code_pass.ptotal:=3;
          code_pass.litragem:=3;
          end
      else if par2='B' then
          begin
          code_pass.ptotal:=3;
          code_pass.litragem:=4;
          end;
      result:=code_pass;
    end;
var virg:virgula;
    abastecimento: abastFid;
    a,inicio,fim: byte;
begin
  inicio:=0;fim:=0;
  for a:=1 to length(SAbast) do
      begin
      if SAbast[a]='(' then inicio:=a else
      if SAbast[a]=')' then fim:=a+1;
      end;
  if SAbast[2]='A' then
    SAbast:='(' + copy(SAbast,3,fim-inicio)
  else
    SAbast:='(' + copy(SAbast,2,fim-inicio);
  virg:=LeVirgula(copy(SAbast,18,2));
  abastecimento.st_full:=SAbast;
  abastecimento.value:=true;
  abastecimento.canal:=copy(SAbast,24,2);
  abastecimento.total_litros:=strtofloat(copy(SAbast,8,virg.litragem) + ',' + copy(SAbast,8+virg.litragem,6-virg.litragem));
  abastecimento.PU:=strtofloat(copy(SAbast,14,virg.ppu) + ',' + copy(SAbast,14+virg.ppu,4-virg.ppu));
  abastecimento.total_dinheiro:=strtofloat(copy(SAbast,2,virg.ptotal) + ',' + copy(SAbast,2+virg.ptotal,6-virg.ptotal));
  abastecimento.data:=copy(SAbast,26,2) + '/' + formatdatetime('mm/yyyy',now);
  abastecimento.hora:=copy(SAbast,28,2) + ':' + copy(SAbast,30,2);
  abastecimento.tempo:=FormataTempo(copy(SAbast,20,4));
  abastecimento.registro:=0;
  abastecimento.encerrante:=0;
  abastecimento.integridade:=true;
  abastecimento.tag:=copy(SAbast,50,16);
  abastecimento.checksum:=ComparaCheck(SAbast);
  if length(SAbast)>=52 then
    begin
      abastecimento.registro:=strtoint(copy(SAbast,34,4));
      abastecimento.encerrante:=strtofloat(copy(SAbast,38,8) + ',' + copy(SAbast,46,2));
      abastecimento.data:=copy(SAbast,26,2) + '/' + copy(SAbast,32,2) + '/' + formatdatetime('yyyy',now);
      if copy(SAbast,48,2)='00' then
          abastecimento.integridade:=true
      else
          abastecimento.integridade:=false;
    end;
  result:=abastecimento;
end;


//------------------------------------------------------------------------------------------------------------
// Função StrtoAbast                                                                                         -
// Entrada: String de abastecimento                                                                          -
// Saída: Estrutura Abast                                                                                    -
// Sub-Functions: LeVirgula                                                                                  -
//------------------------------------------------------------------------------------------------------------
Function StrToAbast(SAbast:string):abast;
    Function LeVirgula(code:string):virgula;
    var code_pass:virgula;
        par1,par2:char;
    begin
      par1:=code[1];
      par2:=code[2];
      code_pass.ppu:=4 - strtoint(par1);
      if par2='A' then
          begin
          code_pass.ptotal:=4;
          code_pass.litragem:=4;
          end
      else if par2='E' then
          begin
          code_pass.ptotal:=4;
          code_pass.litragem:=3;
          end
      else if par2='F' then
          begin
          code_pass.ptotal:=3;
          code_pass.litragem:=3;
          end
      else if par2='B' then
          begin
          code_pass.ptotal:=3;
          code_pass.litragem:=4;
          end;
      result:=code_pass;
    end;

var virg:virgula;
    abastecimento: abast;
    a,inicio,fim: byte;
begin
  inicio:=0;fim:=0;
  for a:=1 to length(SAbast) do
      begin
        if SAbast[a]='(' then inicio:=a else
        if SAbast[a]=')' then fim:=a+1;
      end;
  SAbast:= copy(SAbast,inicio,fim-inicio);
  virg:=LeVirgula(copy(SAbast,18,2));
  {if virg.ptotal>3 then virg.ptotal:=3;
  if virg.ppu>3 then virg.ppu:=3;
  if virg.litragem>3 then virg.litragem:=3;}
  abastecimento.st_full:=SAbast;
  abastecimento.value:=true;
  abastecimento.canal:=copy(SAbast,24,2);
  abastecimento.total_litros:=strtofloat(copy(SAbast,8,virg.litragem) + ',' + copy(SAbast,8+virg.litragem,6-virg.litragem));
  abastecimento.PU:=strtofloat(copy(SAbast,14,virg.ppu) + ',' + copy(SAbast,14+virg.ppu,4-virg.ppu));
  abastecimento.total_dinheiro:=strtofloat(copy(SAbast,2,virg.ptotal) + ',' + copy(SAbast,2+virg.ptotal,6-virg.ptotal));
  abastecimento.data:=copy(SAbast,26,2) + '/' + formatdatetime('mm/yyyy',now);
  abastecimento.hora:=copy(SAbast,28,2) + ':' + copy(SAbast,30,2);
  abastecimento.tempo:= FormataTempo(copy(SAbast,20,4));
  abastecimento.registro:=0;
  abastecimento.encerrante:=0;
  abastecimento.integridade:=true;
  abastecimento.checksum:=ComparaCheck(SAbast);
  if length(SAbast) > 34 then
      begin
        abastecimento.registro:=strtoint(copy(SAbast,34,4));
        abastecimento.encerrante:=strtofloat(copy(SAbast,38,8) + ',' + copy(SAbast,46,2));
        abastecimento.data:=copy(SAbast,26,2) + '/' + copy(SAbast,32,2) + '/' + formatdatetime('yyyy',now);
        if copy(SAbast,48,2)='00' then
            abastecimento.integridade:=true
        else
            abastecimento.integridade:=false;
      end;
  result:=abastecimento;
end;


//------------------------------------------------------------------------------------------------------------
// Função StrtoAbast                                                                                         -
// Entrada: String de abastecimento                                                                          -
// Saída: Estrutura Abast                                                                                    -
// Sub-Functions: LeVirgula                                                                                  -
//------------------------------------------------------------------------------------------------------------
Function StrToAbastReg(SAbast:string):abastReg;
    Function LeVirgula(code:string):virgula;
    var
      code_pass:virgula;
      par1,par2:char;
    begin
    par1:=code[1];
    par2:=code[2];
    code_pass.ppu:=4 - strtoint(par1);
    if par2='A' then
        begin
        code_pass.ptotal:=4;
        code_pass.litragem:=4;
        end
    else if par2='E' then
        begin
        code_pass.ptotal:=4;
        code_pass.litragem:=3;
        end
    else if par2='F' then
        begin
        code_pass.ptotal:=3;
        code_pass.litragem:=3;
        end
    else if par2='B' then
        begin
        code_pass.ptotal:=3;
        code_pass.litragem:=4;
        end;
    result:=code_pass;
    end;
var
    virg:virgula;
    abastecimento: abastReg;
    a,inicio,fim: byte;
begin
inicio:=0;fim:=0;
for a:=1 to length(SAbast) do
    begin
    if SAbast[a]='(' then inicio:=a else
    if SAbast[a]=')' then fim:=a+1;
    end;
SAbast:= copy(SAbast,inicio,fim-inicio);
virg:=LeVirgula(copy(SAbast,18,2));
{if virg.ptotal>3 then virg.ptotal:=3;
if virg.ppu>3 then virg.ppu:=3;
if virg.litragem>3 then virg.litragem:=3;}
abastecimento.st_full:=SAbast;
abastecimento.value:=true;
abastecimento.canal:=copy(SAbast,24,2);
abastecimento.total_litros:=strtofloat(copy(SAbast,8,virg.litragem) + ',' + copy(SAbast,8+virg.litragem,6-virg.litragem));
abastecimento.PU:=strtofloat(copy(SAbast,14,virg.ppu) + ',' + copy(SAbast,14+virg.ppu,4-virg.ppu));
abastecimento.total_dinheiro:=strtofloat(copy(SAbast,2,virg.ptotal) + ',' + copy(SAbast,2+virg.ptotal,6-virg.ptotal));

//abastecimento.data:=copy(SAbast,26,2) + '/' + formatdatetime('mm/yyyy',now);
//abastecimento.hora:=copy(SAbast,28,2) + ':' + copy(SAbast,30,2);

// (ttttttvvvvvvppppvvttttbbddhhmmnn
// 123456789012345678901234567890123
// 0        1         2         3

abastecimento.datetime:=encodedate(yearof(now),strtoint(copy(SAbast,32,2)),strtoint(copy(SAbast,26,2)));
abastecimento.datetime:=abastecimento.datetime + encodetime(strtoint(copy(SAbast,28,2)),strtoint(copy(SAbast,30,2)),0,0);


abastecimento.tempo:= strtoint('$' + copy(SAbast,20,4));
abastecimento.registro:=0;
abastecimento.encerrante:=0;
abastecimento.integridade:=true;
abastecimento.checksum:=ComparaCheck(SAbast);
    abastecimento.registro:=strtoint(copy(SAbast,34,4));
    abastecimento.encerrante:=strtofloat(copy(SAbast,38,8) + ',' + copy(SAbast,46,2));
//    abastecimento.data:=copy(SAbast,26,2) + '/' + copy(SAbast,32,2) + '/' + formatdatetime('yyyy',now);
    if copy(SAbast,48,2)='00' then
        abastecimento.integridade:=true
    else
        abastecimento.integridade:=false;

result:=abastecimento;
end;


//------------------------------------------------------------------------------------------------------------
// Função ABNill                                                                                             -
// Entrada: Nill                                                                                             -
// Saída: Estrutura de abastecimento zerado                                                                  -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function ABNill():abast;
var AbastNull:abast;
begin
with AbastNull do
    begin
      canal:='00';
      value:=false;
      total_dinheiro:=0;
      total_litros:=0;
      PU:=0;
      data:='00/00/0000';
      hora:='00:00';
      tempo:= '00:00:00';
      registro:=0;
      encerrante:=0;
      integridade:=false;
      checksum:=false;
      st_full:='(0000000000000000000000000000000000)';
    end;
result:=AbastNull;
end;


//------------------------------------------------------------------------------------------------------------
// Função ABNill                                                                                             -
// Entrada: Nill                                                                                             -
// Saída: Estrutura de abastecimento zerado                                                                  -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function ABFidNill():abastFid;
var AbastNull:abastFid;
begin
with AbastNull do
    begin
      canal:='00';
      value:=false;
      total_dinheiro:=0;
      total_litros:=0;
      PU:=0;
      data:='00/00/0000';
      hora:='00:00';
      tempo:= '00:00:00';
      registro:=0;
      encerrante:=0;
      integridade:=false;
      checksum:=false;
      tag:='0000000000000000';
      st_full:='(0000000000000000000000000000000000)';
    end;
result:=AbastNull;
end;


//------------------------------------------------------------------------------------------------------------
// Função ABNill                                                                                             -
// Entrada: Nill                                                                                             -
// Saída: Estrutura de abastecimento zerado                                                                  -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function ABFidNill2():abastFid2;
var AbastNull:abastFid2;
begin
with AbastNull do
    begin
      canal:='00';
      value:=false;
      total_dinheiro:=0;
      total_litros:=0;
      PU:=0;
      data:='00/00/0000';
      hora:='00:00';
      tempo:= '00:00:00';
      registro:=0;
      encerrante:=0;
      integridade:=false;
      checksum:=false;
      tag:='0000000000000000';
      tag2:='0000000000000000';
      st_full:='(0000000000000000000000000000000000)';
    end;
result:=AbastNull;
end;


//------------------------------------------------------------------------------------------------------------
// Função ABNill                                                                                             -
// Entrada: Nill                                                                                             -
// Saída: Estrutura de abastecimento zerado                                                                  -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function ABPAF1Nill():abastPAF1;
var AbastNull:abastPAF1;
begin
with AbastNull do
  begin
  value:=false;
  total_dinheiro:=0;
  total_litros:=0;
  PU:=0;
  tempo:='00:00:00';
  codbico:='00';
  numbico:=0;
  numtanque:=0;
  voltanque:=0;
  codcombustivel:=0;
  seriecbc:=0;
  tipocbc:='?';
  data:='00/00/0000';
  hora:='00:00';
  st_full:='(0)';
  registro:=0;
  encerranteI:=0;
  encerranteF:=0;
  integridade:=false;
  checksum:=false;
  tag1:='0000000000000000';
  tag2:='0000000000000000';
  end;
result:=AbastNull;
end;


//------------------------------------------------------------------------------------------------------------
// Função ABNill                                                                                             -
// Entrada: Nill                                                                                             -
// Saída: Estrutura de abastecimento zerado                                                                  -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function ABPAF1NillXE():abastPAF1XE;
var AbastNull:abastPAF1XE;
begin
with AbastNull do
  begin
  value:=false;
  total_dinheiro:=0;
  total_litros:=0;
  PU:=0;
  tempo:='00:00:00';
  codbico:='00';
  numbico:=0;
  numtanque:=0;
  voltanque:=0;
  codcombustivel:=0;
  seriecbc:=0;
  tipocbc:='?';
  data:='00/00/0000';
  hora:='00:00';
  st_full:='(0)';
  registro:=0;
  encerranteI:=0;
  encerranteF:=0;
  integridade:=false;
  checksum:=false;
  tag1:='0000000000000000';
  tag2:='0000000000000000';
  end;
result:=AbastNull;
end;


//------------------------------------------------------------------------------------------------------------
// Função ABNill                                                                                             -
// Entrada: Nill                                                                                             -
// Saída: Estrutura de abastecimento zerado                                                                  -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function ABPAF2Nill():abastPAF2;
var AbastNull:abastPAF2;
begin
  with AbastNull do
    begin
      value:=false;
      total_dinheiro:=0;
      total_litros:=0;
      PU:=0;
      tempo:=0;
      codbico:='00';
      numbico:=0;
      numtanque:=0;
      voltanque:=0;
      codcombustivel:=0;
      seriecbc:=0;
      tipocbc:='?';
      datetime:=now;
      st_full:='(0)';
      registro:=0;
      encerranteI:=0;
      encerranteF:=0;
      integridade:=false;
      checksum:=false;
      tag1:='0000000000000000';
      tag2:='0000000000000000';
    end;
  result:=AbastNull;
end;

function CobAbastIdNill():CobAbastId;
var abastNull:CobAbastId;
begin
  with abastNull do
  begin
    value:='0';
    habilitacao := '0';
    serial_console := '0';
    total_dinheiro := '0';
    total_litros := '0';
    PU := '0';
    cod_virgula := '0';
    tempo := '00:00:00';
    canal := '00';
    data := '00/00/0000';
    hora := '00:00';
    registro := '0';
    encerrante := '0';
    encerrante_inicial := '0';
    bico_pista := '0';
    tipo_combustivel := '0';
    numero_tanque := '0';
    volume_tanque := '0';
    Tag := '0';
    Tag2 := '0';
    integridade := '0';
    checksum:='0';
    st_full := '(0000000000000000000000000000000000)';
  end;
  Result := abastNull;
end;

Function  MemoryPointersNill():MemoryPointers;
var pointersNull: MemoryPointers;
begin
  with pointersNull do
  begin
    readPointer := '0000';
    writePointer := '0000';
  end;
end;

Function ABTWCNill():abastTWC;
var AbastNull:abastTWC;
begin
with AbastNull do
  begin
  value:=false;
  total_dinheiro:=0;
  total_litros:=0;
  PU:=0;
  tempo:='';
  codbico:='00';
  numbico:=0;
  numtanque:=0;
  voltanque:=0;
  codcombustivel:=0;
  seriecbc:=0;
  tipocbc:='?';
  st_full:='(0)';
  registro:=0;
  encerranteI:=0;
  encerranteF:=0;
  integridade:=false;
  checksum:=false;
  tag1:='0000000000000000';
  tag2:='0000000000000000';
  end;
result:=AbastNull;
end;





//------------------------------------------------------------------------------------------------------------
// Função LeAbastecimento                                                                                    -
// Entrada: Nill                                                                                             -
// Saída: Variável formato Tabastecimento                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeAbastecimento(autoIncrement:boolean=true):abast; stdcall; export;
var resposta:string[75];
begin
try
  resposta:=Get('LeAbastecimento','(&A)',2000);
  if (resposta='(0)') or (resposta='SEM RESPOSTA') then
    result:=ABNill
  else if copy(resposta,2,12)='000000000000' then
    begin
    incrementa;
    result:=ABNill;
    end
  else if (length(resposta)=34) or (length(resposta)=52) then
    begin
    if autoIncrement then incrementa;
    result:=StrToAbast(resposta);
    end
  else
    result:=ABNill;
except
  result:=ABNill;
end;
end;

//------------------------------------------------------------------------------------------------------------
//                                                                                                           -
//------------------------------------------------------------------------------------------------------------
Procedure FidIncrementaAbast;stdcall; export;
begin
Get('FidIncrementaAbast','(&I6F)',1);
end;

//------------------------------------------------------------------------------------------------------------
// Função LeAbastecimentoFid                                                                                 -
// Entrada: Nill                                                                                             -
// Saída: Variável formato Tabastecimento                                                                    -
// Sub-Functions: None                                                                                       -
// (A00000000045312343A000B04190931030002001190497200B3CFECD5D280E5E2043800BB)                               -
// (ATTTTTTLLLLLLPPPPVVCCCCBBDDHHMMNNRRRREEEEEEEEEESSXXXXXXXXXXXXXXXXZZZZYYKK)                               -
// 123456789012345678901234567890123456789012345678901234567890123456789012345                               -
// (A00018800016711233A0010041409530800010000000167001234123412341234000100F6)
// (A00014200115212343E0005000100030100010000099393000000000000000000010060)
// (A00052200227922893E0005040101010100880000025246000000000000000000001B)      // string simulador
// (00096800412823453A00110413110701005300000041280073)
// (A00033100120627503E000504171448010423000039597100B3CFECD5BAA623CE099700E4)
//          1         2         3         4         5         6         7                                    -
//------------------------------------------------------------------------------------------------------------
Function LeAbastecimentoFid:AbastFid; stdcall; export;
var resposta:string[75];
    comando:string[6];
begin
  comando:=AdicionaCheck('(&A');
  resposta:=Get('LeAbastecimentoFid',comando,1500);

  if(length(resposta)=75) then
    begin
      FidIncrementaAbast;
      result:=StrToAbastFid(resposta);
    end
  else
    result:=ABFidNill;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeAbastecimentoFid2                                                                                -
// Entrada: Nill                                                                                             -
// Saída: Variável formato Tabastecimento                                                                    -
// Sub-Functions: None
//(@TTTTTTLLLLLLPPPPVVCCCCBBDDHHMMNNRRRREEEEEEEEEEssIIIIIIIIIIIIIIIIiiiiiiiiiiiiiiiiSSKK)
//123456789012345678901234567890123456789012345678901234567890123456789012345678901234567                    -
//0        1         2         3         4         5         6         7         8
//------------------------------------------------------------------------------------------------------------

Function LeAbastecimentoFid2:AbastFid2; stdcall; export;
var resposta:string[87];
    comando:string[6];
begin
comando:=AdicionaCheck('(&@');
resposta:=Get('LeAbastecimentoFid2',comando,1500);

if (length(resposta)=87) then
    begin
    FidIncrementaAbast;
    result:=StrToAbastFid2(resposta);
    end
else
    result:=ABFidNill2;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeAbastecimentoFid2                                                                                -
// Entrada: Nill                                                                                             -
// Saída: Variável formato Tabastecimento                                                                    -
// Sub-Functions: None

//(a230000088600800000252631673A00888828091510130013840038903833003890130709020300D0D0D0B3CF6C81BF34BF6BFFFFFFFFFFFFFFFF00E3)

//(a2G0000511800040000324212343E00070405114707110008770000555351000055502612345600987654000000000000000000000000000000000081) 
//(a2$SSSSSSSSTTTTTTLLLLLLPPPPVVCCCCBBDDHHMMNNAARRRRRRffffffffffiiiiiiiiiibbccttvvvvvvvvIIIIIIIIIIIIIIIIJJJJJJJJJJJJJJJJnnKK) 
//123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
//0        1         2         3         4         5         6         7         8         9        10        11        12
//------------------------------------------------------------------------------------------------------------
Function LeAbastecimentoPAF1(autoIncrement:boolean=true):AbastPAF1; stdcall; export;
var resposta:string[123];
    comando:string[7];
begin
  try
   comando:='(&A299)';
   resposta:=Get('LeAbastecimentoPAF1',comando,3000);
   if (length(resposta)=123) then
    begin
      if autoIncrement then Incrementa;
      result:=StrToAbastPAF1(resposta);


//    messagedlg( 'data: ' + result.data  ,mterror,[mbok],0);
//    messagedlg( 'tag2: ' + FloatToStr( result.encerranteF)  ,mterror,[mbok],0);
//    messagedlg( 'full: ' + result.st_full  ,mterror,[mbok],0);

    end
    else
    result:=ABPAF1Nill;
  except
    result:=ABPAF1Nill;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeAbastecimentoFid2                                                                                -
// Entrada: Nill                                                                                             -
// Saída: Variável formato Tabastecimento                                                                    -
// Sub-Functions: None      
//(a2G0000511800040000324212343E00070405114707110008770000555351000055502612345600987654000000000000000000000000000000000081) 
//(a2$SSSSSSSSTTTTTTLLLLLLPPPPVVCCCCBBDDHHMMNNAARRRRRRffffffffffiiiiiiiiiibbccttvvvvvvvvIIIIIIIIIIIIIIIIJJJJJJJJJJJJJJJJnnKK) 
//123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
//0        1         2         3         4         5         6         7         8         9        10        11        12
//------------------------------------------------------------------------------------------------------------
Function LeAbastecimentoPAF1XE:AbastPAF1XE; stdcall; export;
var resposta:widestring;
    comando:string[7];
begin
try
comando:='(&A299)';
resposta:=Get('LeAbastecimentoPAF1',comando,3000);
if (length(resposta)=123) then
    begin
    Incrementa;
    result:=StrToAbastPAF1XE(resposta);
    end
else
    result:=ABPAF1NillXE;
except
  result:=ABPAF1NillXE;
end;
end;

//--------------------------------------------------------------------------------------------------------------------------------
//RX : (&A299)
//TX : (a2G9999999900002900002611233A00010426093107130000050001138565000113853900000000000000111111111111111100000000000000000085)
//     123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
//     (a2G0000511800040000324212343E00070405114707110008770000555351000055502612345600987654000000000000000000000000000000000081)
//     (a230000241900011100041326903E12304814155612130000300035006482195435367008010100FF75F80000000000000000000000000000000000A3)
//--------------------------------------------------------------------------------------------------------------------------------
Function LeAbastecimentoPAF2:AbastPAF2; stdcall; export;
var resposta:string[123];
    comando:string[7];
begin
try
comando:='(&A299)';
resposta:=Get('LeAbastecimentoPAF2',comando,3000);
//resposta:='(a230000241900011100041326903E12304814155612130000300035006482195435367008010100FF75F80000000000000000000000000000000000A3)';
if (length(resposta)=123) then
    result:=StrToAbastPAF2(resposta)
else
    result:=ABPAF2Nill;
except
  result:=ABPAF2Nill;
end;
end;

Function LeAbastecimentoPAFReg(number:integer):AbastPAF2; stdcall; export;
var resposta:string[123];
    comando:string;
    stNumber:string[4];
begin
try
  stNumber:=inttostr(number);
  while length(stNumber)<4 do stNumber:='0' + stNumber;
  //stNumber := Format('%.*d',[4,number]);
  comando:='(&LC' + stNumber;
  comando:= AdicionaCheck(comando);
  //messagedlg('comando: ' + comando,mtinformation,[mbok],0);
  resposta:=Get('LeAbastecimentoPAFReg',comando,3000);
  //resposta:='(a230000241900011100041326903E12304814155612130000300035006482195435367008010100FF75F80000000000000000000000000000000000A3)';
  if (length(resposta)=123) then
      result:=StrToAbastPAF2(resposta)
  else
     result:=ABPAF2Nill;
  except
   result:=ABPAF2Nill;
  end;
end;

Function LeAbastecimentoTWC:AbastTWC; stdcall; export;
var resposta:string[150];
    comando:string[10];
begin
  try
    comando:='(&A299)';
    resposta:=Get('LeAbastecimentoTWC',comando,3000);
    if (length(resposta)=123) then
      result:= StrToAbastTWC(resposta)
    else
      result:=ABTWCNill;
  except
    result:=ABTWCNill;
  end;
end;

//--------------------------------------------------------------------------------------------------------------------------------
Function LeAbastecimentoPAF1Fix:AbastPAF1; stdcall; export;
var resposta:string[123];
    comando:string[7];
begin
  try
    comando:='(&A299)';
    resposta:=Get('LeAbastecimentoPAF1',comando,3000);
    if (length(resposta)=123) then
      result:=StrToAbastPAF1(resposta)
    else
      result:=ABPAF1Nill;
  except
    result:=ABPAF1Nill;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeAbastecimentoFid                                                                                 -
// Entrada: Nill                                                                                             -
// Saída: Variável formato Tabastecimento                                                                    -
// Sub-Functions: None                                                                                       -
// (A00000000045312343A000B04190931030002001190497200B3CFECD5D280E5E2043800BB)                               -
// (ATTTTTTLLLLLLPPPPVVCCCCBBDDHHMMNNRRRREEEEEEEEEESSXXXXXXXXXXXXXXXXZZZZYYKK)                               -
// 123456789012345678901234567890123456789012345678901234567890123456789012345                               -
// (A00018800016711233A0010041409530800010000000167001234123412341234000100F6)
// (A00014200115212343E0005000100030100010000099393000000000000000000010060)
// (A00052200227922893E0005040101010100880000025246000000000000000000001B)      // string simulador
// (00096800412823453A00110413110701005300000041280073)
// (A00033100120627503E000504171448010423000039597100B3CFECD5BAA623CE099700E4)
//          1         2         3         4         5         6         7                                    -
//------------------------------------------------------------------------------------------------------------
Function LeAbFidFix:AbastFid; stdcall; export;
var resposta:string[75];
    comando:string[6];
begin
comando:=AdicionaCheck('(&A');
resposta:=Get('LeAbastecimentoFid',comando,1500);

if (length(resposta)=75) then
    begin
//    FidIncrementaAbast;
    result:=StrToAbastFid(resposta);
    end
else
    result:=ABFidNill;
end;

//------------------------------------------------------------------------------------------------------------
function GetSaleVolume:double;
var Ab:Abast;
begin
  ab:=LeAbFix;
  result:=ab.total_litros;
end;

function GetSaleIndex:integer;
var Ab:Abast;
begin
  ab:=LeAbFix;
  result:=ab.registro;
end;


//(TP9974879400BD)
function GetMemoryPointers:MemoryPointers; stdcall; export;
var
  command, answer : string;
begin
  try
      command := '(&T99P3C)';
      answer := Get('GetMemoryPointers',command, 2000);
      if(Length(answer)= 16) then
        Result := StrToMemoryPointers(answer)
      else
        Result := MemoryPointersNill;
    except
      Result := MemoryPointersNill;
      end;
end;


function GetSalePoint:integer;
var Ab:Abast;
begin
  ab:=LeAbFix;
  result:=strtoint('$' + ab.canal);
end;

//------------------------------------------------------------------------------------------------------------
Function LeAbFid2Fix:AbastFid2; stdcall; export;
var resposta:string[87];
    comando:string[6];
begin
  comando:=AdicionaCheck('(&@');
  resposta:=Get('LeAbastecimentoFid2',comando,1500);

  if (length(resposta)=87) then
    begin
      //FidIncrementaAbast;
      result:=StrToAbastFid2(resposta);
    end
  else
    result:=ABFidNill2;
end;


//------------------------------------------------------------------------------------------------------------
// Função saveTagFid
// Comando   (?FCCGttttttttttttttttAAAAaaaaBBBBbbbbKK)
// Resposta: (FGP[6]M[6]T[16]AAAAaaaaBBBBbbbbCCKK)
{
--------------------------------------------
Controle 1
--------------------------------------------
1  TAG Veículo
2  TAG Máquina de Lavar
3  Reservado
4  Cliente Nível 1
5  Cliente Nível 2
6  Cliente Nível 3
7  Funcionário Nível 1
8  Funcionário Nível 2
9  Funcionário Nível 3
A  Funcionário Nível 4
B  Funcionário Nível 5
C  Funcionário Nível 6
D  Gerente Nível 1
E  Gerente Nível 2
F  Controle Total
--------------------------------------------
Controle 2
--------------------------------------------
1  Reservado
2  Libera Bombas
4  Respeita turnos
8  Liga máquina de lavagem
6  Libera bombas / Respeita turnos
A  Libera bombas / Liga máquina de lavar
--------------------------------------------
txin/txout: HHMM
}
Function saveTagFid(controle1,controle2:char;tag,t1in,t1out,t2in,t2out:string):integer; stdcall; export;
var
  controle:string[2];
  comando:string;
  resposta:string;
begin
  controle:=controle2 + controle1;
  comando:=AdicionaCheck('(?F'+controle+'G'+tag+t1in+t1out+t2in+t2out);
  if length(comando)=41 then
    begin
      //ShowMessage(tag);
      resposta:=Get('SaveTagFid',comando,2000);
      //(FGppppppMMMMMMttttttttttttttttAAAAaaaaBBBBbbbbCCKK)
      //1234567890123456789012345678901234567890123456789012
      //0        1         2         3         4         5
    if (length(resposta)=52) then
      begin
        if copy(resposta,1,3)='(FG' then
          result:=strtoint(copy(resposta,4,6))
        else
        result:=-1;
      end
    end
  else
    result:=-1;
end;

//------------------------------------------------------------------------------------------------------------
// Função deleteTagFid                                                                                       -
// Entrada: Tag,Indice                                                                                       -
// Saída: 1-apagou, 0=não apagou
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
{
Comando:  
(?FXXATTTTTTTTTTTTTTTT00RRRRRR00000000KK)
12345678901234567890123456789012345678901
0        1         2         3         4
Resposta:
(FAXXXXXXSSSSSSCCCCCCCCCCCCCCCCIIIIIIIIFFFFFFFFXXKK)
1234567890123456789012345678901234567890123456789012
0        1         2         3         4         5
}
Function deleteTagFid(posicao:integer;tag:string):integer; stdcall; export;
var stPosicao:string[6];
    comando,resposta:string;
begin
  stPosicao:=inttostr(posicao);
  while length(stPosicao)<6 do stPosicao:='0'+stPosicao;
  comando:=AdicionaCheck('(?FFFA'+tag+'00'+stPosicao+'00000000');
  if length(comando)=41 then
    begin
      resposta:=Get('deleteTagFid',comando,2000);
      if length(resposta)=52 then
        begin
          result:=strtoint(copy(resposta,4,6));
        end
      else
      result:=0;
    end
  else
    result:=0;
end;

//------------------------------------------------------------------------------------------------------------
// Função clearTagFid                                                                                       -
// Entrada: none
// Saída: none
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
{Comando: (?F00L0000000000000000000000010000000032) }
procedure clearTagFid; stdcall; export;
begin
  Get('clearTagFid','(?F00L0000000000000000000000010000000032)',5000);
end;

//------------------------------------------------------------------------------------------------------------
// Função readTagFid                                                                                       -
// Entrada: indice
// Saída: none
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
{Comando: (?FLxxxxxxKK) }
function readTagFid(indice:integer;var tag,controle,t1in,t1out,t2in,t2out:pchar):integer;  stdcall; export;
var
  comando,resposta:string;
  stIndice:string[6];
begin
  tag:='';controle:='';t1in:='';t1out:='';t2in:='';t2out:='';
  stIndice:=inttostr(indice);
  while length(stIndice)<6 do stIndice:='0' + stIndice;
  comando:=adicionacheck('(?LF'+stIndice);
  //messagedlg('Comando: ' + comando,mtinformation,[mbok],0);
  resposta:=Get('readTagFid',comando,2000);
  //messagedlg('Resposta: ' + comando,mtinformation,[mbok],0);
  if length(resposta)=52 then
    begin
      tag:=pchar(copy(resposta,16,16));
      controle:=pchar(copy(resposta,48,2));
      t1in:=pchar(copy(Resposta,32,4));
      t1out:=pchar(copy(Resposta,36,4));
      t2in:=pchar(copy(Resposta,40,4));
      t2out:=pchar(copy(Resposta,44,4));
      result:=1;
    end
  else
  result:=0;

end;

//------------------------------------------------------------------------------------------------------------
// Função lerTagIdf                                                                                          -
// Entrada: indice                                                                                           -
// Saída: none                                                                                               -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
{Comando: (?FLxxxxxxKK) }
function lerTagIdf(indice: Integer):ShortString; stdcall; export;
var
  stIndice: string[6];
  comando, resposta: string;
begin
  stIndice := IntToStr(indice);
  while length(stIndice)<6 do
    stIndice := '0' + stIndice;

  comando := AdicionaCheck('(?LF' + stIndice);
  resposta := Get('lerTagIdf',comando,2000);

  if resposta = 'FALHA' then
    Result := 'FALHA'
  else
    result := resposta;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeAbFix                                                                                            -
// Entrada: Nill                                                                                             -
// Saída: Variável formato Tabastecimento                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeAbFix():abast; stdcall; export;
var   resposta:string[75];
begin
  resposta:=Get('LeAbFix','(&A)',2000);
  //messagedlg('LeAbFix: ' + resposta,mtinformation,[mbok],0);
  if (resposta='(0)') then
    result:=ABNill
  else if copy(resposta,2,12)='000000000000' then
    begin
      incrementa;
      result:=ABNill;
    end
  else if (length(resposta)=34) or (length(resposta)=52) then
    result:=StrToAbast(resposta)
  else result:=abnill;
end;

//------------------------------------------------------------------------------------------------------------
// Procedimento FormataStructAb (interno)                                                                    -
// Entrada: struct Ab (ref)                                                                                  -
// saída: Referencial                                                                                        -
// Sub-functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure FormataStructAb(resposta:string;var ab:abast2);
begin
if ((length(resposta)=34) or (length(resposta)=52)) then
    begin
      ab.value:='1';
      ab.total_dinheiro:=copy(resposta,2,6);
      ab.total_litros:=copy(resposta,8,6);
      ab.PU:=copy(resposta,14,4);
      ab.tempo:=formatatempo(copy(resposta,20,4));
      ab.canal:=copy(resposta,24,2);
      if length(resposta)=34 then ab.data:=copy(resposta,26,2) + '/' + formatdatetime('mm/yyyy',now) else
      if length(resposta)=52 then ab.data:=copy(resposta,26,2) + '/' + copy(resposta,32,2) + '/' + formatdatetime('yyyy',now);
      ab.hora:=copy(resposta,28,2) + ':' + copy(resposta,30,2);
      ab.st_full:=resposta;
      if length(resposta)=52 then ab.registro:=copy(resposta,34,4) else
      if length(resposta)=34 then ab.registro:='0000';
      if length(resposta)=52 then ab.encerrante:=copy(resposta,38,10) else
      if length(resposta)=34 then ab.encerrante:='0000000000';
      if length(resposta)=52 then ab.integridade:=resposta[49] else
      if length(resposta)=34 then ab.integridade:='1';
      if ComparaCheck(resposta)=true then ab.checksum:='1' else ab.checksum:='0';
    end
else
    begin
      ab.value:='0';
      ab.total_dinheiro:='0';
      ab.total_litros:='0';
      ab.PU:='0';
      ab.tempo:='00:00:00';
      ab.canal:='00';
      ab.data:='00/00/0000';
      ab.hora:='00:00';
      ab.st_full:='(0000000000000000000000000000000000)';
      ab.registro:='0';
      ab.encerrante:='0';
      ab.integridade:='0';
      ab.checksum:='0';
    end;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStructSt                                                                                         -
// Entrada: variável strutura (referencia)                                                                   -
// Saída: variável estrutura (referencia)                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure LeStructSt(var ab:abast2);stdcall; export;
var resposta:string[75];
begin
resposta:=Get('LeStructSt','(&A)',1000);
if (resposta<>'') and (resposta<>'(0)') then incrementa;
FormataStructAb(resposta,ab);
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStructSt                                                                                         -
// Entrada: variável strutura (referencia)                                                                   -
// Saída: variável estrutura (referencia)                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure LeStructStFix(var ab:abast2);stdcall; export;
var resposta:string[75];
begin
resposta:=Get('LeStructSt','(&A)',1000);
FormataStructAb(resposta,ab);
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStructIDStFix                                                                                         -
// Entrada: variável strutura (referencia)                                                                   -
// Saída: variável estrutura (referencia)                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure LeStructIDStFix(var ab:abast3);stdcall; export;
var resposta:string[75];
begin
resposta:=Get('CobLeStructSt','(&A67)',2000);
if (length(resposta)=75) then
    begin
    if resposta[2]='A' then ab.value:='1' else ab.value:='0';
    ab.total_dinheiro:=copy(resposta,3,6);
    ab.total_litros:=copy(resposta,9,6);
    ab.PU:=copy(resposta,15,4);
    ab.tempo:=formatatempo(copy(resposta,21,4));
    ab.canal:=copy(resposta,25,2);
    ab.data:=copy(resposta,27,2) + '/' + copy(resposta,33,2) + '/' + formatdatetime('yyyy',now);
    ab.hora:=copy(resposta,29,2) + ':' + copy(resposta,31,2);
    ab.st_full:=resposta;
    ab.registro:=copy(resposta,35,4);
    ab.encerrante:=copy(resposta,39,10);
    ab.integridade:=resposta[49];
    ab.id:=copy(resposta,51,16);
    //FidIncrementaAbast;
    if ComparaCheck(resposta) then ab.checksum:='1' else ab.checksum:='0';
    end
else if resposta='(0)' then
    begin
    ab.value:='0';
    ab.total_dinheiro:='0';
    ab.total_litros:='0';
    ab.PU:='0';
    ab.tempo:='00:00:00';
    ab.canal:='00';
    ab.data:='00/00/0000';
    ab.hora:='00:00';
    ab.st_full:='(0000000000000000000000000000000000)';
    ab.registro:='0';
    ab.encerrante:='0';
    ab.integridade:='0';
    ab.checksum:='0';
    end
else
    begin
    ab.value:='0';
    ab.total_dinheiro:='0';
    ab.total_litros:='0';
    ab.PU:='0';
    ab.tempo:='00:00:00';
    ab.canal:='99';
    ab.data:='00/00/0000';
    ab.hora:='00:00';
    ab.st_full:=resposta;
    ab.registro:='0';
    ab.encerrante:='0';
    ab.integridade:='0';
    ab.checksum:='0';
    end;
resposta:='';
end;

//------------------------------------------------------------------------------------------------------------
// Procedimento FechaPorta                                                                                   -
// Entrada: Nill                                                                                             -
// Saída: Nill                                                                                               -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function FechaSerial: DWORD; stdcall; export;
begin
if CloseSerial then
  result:=1
else
  result:=0;
end;

//------------------------------------------------------------------------------------------------------------
// Procedimento FechaSocket                                                                                  -
// Entrada: Nill                                                                                             -
// Saída: Nill                                                                                               -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function FechaSocket: boolean; stdcall; export;
begin
  result := CloseSocket;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStatus                                                                                           -
// Entrada: Nill                                                                                             -
// Saída: Estrutura de status                                                                                -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
procedure EscreveSerial(st:ansistring);stdcall; export;
begin
SendText('EscreveSerial',st);
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStatus                                                                                           -
// Entrada: Nill                                                                                             -
// Saída: Estrutura de status                                                                                -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeStatus():multistatus; stdcall; export;
var stbomba:multistatus;
    resposta:string[75];
    a:integer;
begin
resposta:=Get('LeStatus','(&S)',2000);
//messagedlg('LeStatus: ' + resposta,mtinformation,[mbok],0);
For a:=1 to 48 do stbomba.Status[a]:=Falha;
if (resposta<>'') and (resposta[2]='S') then
    begin
    For a:=3 to length(resposta)-1 do
        begin
        case resposta[a] of
            'L':stbomba.Status[a-2]:= Livre;
            'P':stbomba.Status[a-2]:= Pronta;
            'F':stbomba.Status[a-2]:= Falha;
            'C':stbomba.Status[a-2]:= Concluiu;
            'A':stbomba.Status[a-2]:= Abastecendo;
            'B':stbomba.Status[a-2]:= Bloqueada;
            'E':stbomba.Status[a-2]:= SolicitaLib;
            else Break;
          end;
        end;
    end
else if resposta<>'SEM RESPOSTA' then
    begin
    for a:=1 to 48 do stbomba.Status[a-2]:=Falha;
    end;
result:=stbomba;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStatus                                                                                           -
// Entrada: Nill                                                                                             -
// Saída: Estrutura de status                                                                                -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeStatusFid():multistatus; stdcall; export;
var stbomba:multistatus;
    resposta:string[75];
    comando:string[6];
    a:integer;
begin
comando:=AdicionaCheck('(&S');
resposta:=Get('LeStatusFid',comando,1000);
For a:=1 to 32 do stbomba.Status[a]:=Falha;
if (resposta<>'') and (resposta[2]='S') then
    begin
    For a:=3 to length(resposta)-1 do
        begin
            case resposta[a] of
            'L':stbomba.Status[a-2]:= Livre;
            'P':stbomba.Status[a-2]:= Pronta;
            'F':stbomba.Status[a-2]:= Falha;
            'C':stbomba.Status[a-2]:= Concluiu;
            'A':stbomba.Status[a-2]:= Abastecendo;
            'B':stbomba.Status[a-2]:= Bloqueada;
            'E':stbomba.Status[a-2]:= SolicitaLib;
            else
            stbomba.Status[a-2]:= Falha;
            end;
        end;
    end
else if resposta<>'SEM RESPOSTA' then
    begin
    for a:=1 to 32 do stbomba.Status[a]:=SolicitaLib;
    end;
result:=stbomba;
end;

//------------------------------------------------------------------------------------------------------------
// Função SetClock                                                                                           -
// Entrada: ddhhmm  ->  dd=dia hh=Hora mm=Minuto ou auto=automatico                                          -
// Saída: True se acertou senão False                                                                        -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function SetClock(par:string):boolean; stdcall; export;
var     resposta,comando:string;
        cont:byte;
        dia,hora,minuto:byte;
begin
try
  if (uppercase(par)='AUTO') then
    comando:='(&H' + formatdatetime('ddhhnn',now) + ')'
  else
    begin
    dia:=strtoint(copy(par,1,2));
    hora:=strtoint(copy(par,3,2));
    minuto:=strtoint(copy(par,5,2));
    if parseDate(hora,minuto,dia,monthof(now),yearof(now)) then
      begin
      comando:='(&H' + par + ')';
      cont:=0;resposta:='';
      while (resposta<>'(&H)') and (cont<3) do
        begin
        resposta:=Get('SetClock',comando,5000);
        inc(cont);
        end;
      if resposta='(&H)' then
        result:=true
      else
        result:=false;
      end
    else
      result:=false;
    end;
except
  result:=false;
end;
end;

//------------------------------------------------------------------------------------------------------------
// Função SetIntClock                                                                                        -
// Entrada: ddhhmm  ->  dd=dia hh=Hora mm=Minuto ou auto=automatico                                          -
// Saída: True se acertou senão False                                                                        -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function SetIntClock(dia,hora,minuto:byte):boolean; stdcall; export;
var resposta,comando:string;
    stDia,stHora,stMinuto:string[2];
    cont:byte;
begin
if parseDate(hora,minuto,dia,monthof(now),yearof(now)) then
  begin
  stDia:=inttostr(dia);
  stHora:=inttostr(hora);
  stMinuto:=inttostr(minuto);
  while length(stDia)<2 do stDia:='0' + stDia;
  while length(stHora)<2 do stHora:='0' + stHora;
  while length(stMinuto)<2 do stMinuto:='0' + stMinuto;
  comando:='(&H' + stDia + stHora + stMinuto + ')';
  resposta:='';cont:=0;
  while (resposta<>'(&H)') and (cont<3) do
    begin
    resposta:=Get('SetIntClock',comando,500);
    inc(cont);
    end;
  if resposta='(&H)' then result:=true else result:=false;
  end
else
  result:=false;
end;

//------------------------------------------------------------------------------------------------------------
// Função SetExtendedWatch                                                                                   -
// Entrada: Parâmetros de horário                                                                            -
// Saída: Boolean                                                                                            -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
function SetExtendedWatch(ano,mes,dia,diaSemana,hora,minuto,segundo:string):boolean;stdcall;export;
var stAno,stMes,stDia,stDiaSemana,stHora,stMinuto,stSegundo:string[2];
    comando, resposta:string;
begin
  stAno := ano;
  stMes := mes;
  stDia := dia;
  stDiaSemana := diaSemana;
  stHora := hora;
  stMinuto := minuto;
  stSegundo := segundo;

  while length(stAno)<2 do stAno:='0' + stAno;
  while length(stMes)<2 do stMes:='0' + stMes;
  while length(stDia)<2 do stDia:='0' + stDia;
  while length(stDiaSemana)<2 do stDiaSemana:='0' + stDiaSemana;
  while length(stHora)<2 do stHora:='0' + stHora;
  while length(stMinuto)<2 do stMinuto:='0' + stMinuto;
  while length(stSegundo)<2 do stSegundo:='0' + stSegundo;

  comando := adicionacheck('(&KW1' + stAno + stMes + stDia + stDiaSemana + stHora + stMinuto + stSegundo);
  //ShowMessage(comando);
  resposta := Get('SetExtendedWatch',comando,1000);

  if resposta = '' then
    result := false
  else
    result := true
end;
//------------------------------------------------------------------------------------------------------------
// Função LeVisualizacao                                                                                     -
// Entrada: Nill                                                                                             -
// Saída: Estrutura de visualizacao                                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeVisualizacao():OnLine; stdcall; export;
var VOnline:online;
    Resposta:string[200];
    a,pos_bico,pos_litro:byte;
    bicos:real;
begin
resposta:=Get('LeVisualizacao','(&V)',1000);
if ((length(resposta)-2) mod 8)=0 then
    begin
    For a:=1 to 48 do
        begin
        vonline.Litragem[a]:=0;
        vonline.Bico[a]:='00';
        end;
    result:=VOnLine;
    if resposta[1]='(' then
        begin
        try
            Bicos:=(length(resposta)-2)/8;
        except
            exit;
        end;
        if bicos>=1 then
            begin
            pos_bico:=2;pos_litro:=4;
            for a:=1 to trunc(bicos) do
                    begin
                    VOnLine.Bico[a]:=copy(resposta,pos_bico,2);
                    VOnLine.Litragem[a]:=strtofloat(copy(resposta,pos_litro,4) + ',' + copy(resposta,pos_litro+4,2));
                    inc(pos_bico,8);
                    inc(pos_litro,8);
                    end;
            end;
        end;
    result:=VOnLine;
    end
else
    begin
    for a:=1 to 48 do
        begin
        VOnLine.Bico[a]:='00';
        VOnLine.Litragem[a]:=0;
        end;
    result:=VOnLine;
    end;
end;

//------------------------------------------------------------------------------------------------------------
// Função ConsultaCodigoVirgulaPPL                                                                           =
// Entrada: bico                                                                                             =
// Saída: Retorna o código de vírgula do bico                                                                =
// Sub-Functions: none                                                                                       =
//------------------------------------------------------------------------------------------------------------
function ConsultaCodigoVirgulaPPL(bico:string):integer;stdcall;export;
var
  comando: string;
  resposta: string;
begin
  if length(bico)=2 then
  begin
    comando := AdicionaCheck('(&T' + bico + 'C');
    resposta := Get('ConsultaCodigoVirgulaPPL',comando,2000);
    if Length(resposta) = 16 then
    begin
      Result := StrToInt(Copy(resposta,8,1));
      end
    else
    begin
      Result := 0;
    end;
  end
  else
  begin
    result := 0;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função InformaErro                                                                                        -
// Entrada: String de modo / preset / encerrantes / Alteração de PU                                          -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function InformaErro(st:string;bico:string):Error;
begin
  bico:=copy(bico,1,2);
  result:=none;
  if (length(st)=5) then
      begin
        if st[3]='?' then
            begin
            case st[4] of
              'b':result:=ErroCodBico;
              'm':result:=ErroCaracterModo;
              't':result:=ErroTimeout;
              'r':result:=ErroResposta;
            end;
        end
        else if (copy(st,3,2)=bico) then result:=None
        else result:=ErroString;
      end
  else result:=ErroString;
end;

//------------------------------------------------------------------------------------------------------------
// Função AlteraModo                                                                                         -
// Entrada: Nº do bico,opção L A B S                                                                         -
// Saída: Estrutura Error                                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function AlteraModo(bico:string;option:char):Error;
var resposta,comando:string[50];
begin
bico:=copy(bico,1,2);
comando:=AdicionaCheck('(&M' + bico + option);
resposta:=Get('AlteraModo',comando,1000);
result:=InformaErro(resposta,bico);
end;

//------------------------------------------------------------------------------------------------------------
// Função AutorizaAbast                                                                                      -
// Entrada: Nº do bico ou '00' para todas bombas                                                             -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function AutorizaAbast(bico:string):Error; stdcall; export;
begin
result:=AlteraModo(bico,'A');
end;

//------------------------------------------------------------------------------------------------------------
// Função SetAutorizaAbast                                                                                   -
// Entrada: Nº do bico ou '00' para todas bombas                                                             -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function SetAutorizaAbast(bico:string):boolean; stdcall; export;
begin
if AlteraModo(bico,'A')=None then
   result:=true
else
   result:=false
end;

//------------------------------------------------------------------------------------------------------------
// Função BloqueiaBico                                                                                       -
// Entrada: Nº do bico ou '00' para todas bombas                                                             -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function BloqueiaBico(bico:string):Error; stdcall; export;
begin
result:=AlteraModo(bico,'B');
end;

//------------------------------------------------------------------------------------------------------------
// Função SetBloqueiaBico                                                                                    -
// Entrada: Nº do bico ou '00' para todas bombas                                                             -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function SetBloqueiaBico(bico:string):boolean; stdcall; export;
begin
if AlteraModo(bico,'B')=none then
   result:=true
else
   result:=false;
end;

//------------------------------------------------------------------------------------------------------------
// Função AutoLibera                                                                                         -
// Entrada: Nº do bico '00' p/ todas bombas                                                                  -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function AutoLibera(bico:string):Error; stdcall; export;
begin
result:=AlteraModo(bico,'L');
end;

//------------------------------------------------------------------------------------------------------------
// Função SetAutoLibera                                                                                      -
// Entrada: Nº do bico '00' p/ todas bombas                                                                  -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function SetAutoLibera(bico:string):boolean; stdcall; export;
begin
if AlteraModo(bico,'L')=none then
   result:=true
else
   result:=false;
end;

//------------------------------------------------------------------------------------------------------------
// Função ParaBomba                                                                                          -
// Entrada: Nº do bico '00' p/ todas bombas                                                                  -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function ParaBomba(bico:string):Error; stdcall; export;
begin
result:=AlteraModo(bico,'S');
end;

//------------------------------------------------------------------------------------------------------------
// Função SetParaBomba                                                                                       -
// Entrada: Nº do bico '00' p/ todas bombas                                                                  -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function SetParaBomba(bico:string):boolean; stdcall; export;
begin
if AlteraModo(bico,'S')=none then result:=true else result:=false;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeRegistro                                                                                         -
// Entrada: Nº do registro                                                                                   -
// Saída: Estrutura abastecimento                                                                            -
// Sub-Functions: None
// (00300101072327993E0000101817151100010023726587000000000000000000000100A8)                                                                                     -
// 12345678901234567890123456789012345678901234567890123456789012345678901234
//------------------------------------------------------------------------------------------------------------
Function LeRegistro(NumReg:integer):abast; stdcall; export;
var STReg:string[4];
    resposta:string[100];
    comando:string;
begin
STReg:=inttostr(NumReg);
while length(STReg)<4 do STReg:='0' + STReg;
comando:=AdicionaCheck('(&LR' + copy(STReg,1,4));
resposta:=Get('LeRegistro',comando,2000);
//messagedlg(comando + '-' + resposta,mtinformation,[mbok],0);

if (copy(resposta,24,2)<>'00') and (copy(resposta,2,6)<>'FFFFFF') then
  begin
  if (length(resposta)>=52) then
    begin
      resposta:=copy(resposta,1,51)+')';
      result:=StrToAbast(resposta);
    end
  end
else
    result:=ABNill;
end;


Function LeRegistro3(NumReg:integer):abastReg; stdcall; export;
var STReg:string[4];
    resposta:string[100];
    comando:string;
begin
  STReg:=inttostr(NumReg);
  while length(STReg)<4 do STReg:='0' + STReg;
  comando:=AdicionaCheck('(&LR' + copy(STReg,1,4));
  resposta:=Get('LeRegistro',comando,2000);
  //resposta:='(00121400057221233A00065C03170106000200000005720072)';
  if (copy(resposta,24,2)<>'00') and (copy(resposta,2,6)<>'FFFFFF') then
    begin
      if (length(resposta)>=52) then
        begin
          resposta:=copy(resposta,1,51)+')';
          result:=StrToAbastReg(resposta);
        end
    end
    else
      result.value:=false;
end;




//------------------------------------------------------------------------------------------------------------
// Função LeRegistro2                                                                                         -
// Entrada: Nº do registro                                                                                   -
// Saída: Estrutura abastecimento                                                                            -
// Sub-Functions: None
// (00238000992024003A000B04120955010032000019071800B3CF890155F5B8A700320053)
//------------------------------------------------------------------------------------------------------------
Function LeRegistro2(NumReg:integer):shortstring; stdcall; export;
var STReg:string[4];
    resposta:string[100];
    comando:string;
begin
  STReg:=inttostr(NumReg);
  while length(STReg)<4 do STReg:='0' + STReg;
  comando:=AdicionaCheck('(&LR' + copy(STReg,1,4));
  resposta:=Get('LeRegistro',comando,2000);

  if (copy(resposta,24,2)<>'00') and (copy(resposta,2,6)<>'FFFFFF') and (length(resposta)=74) then
    result:=resposta
  else
    result:='<STRING ERROR>' + resposta;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeRegistroComp                                                                                        -
// Entrada: Nº do registro                                                                                   -
// Saída: Estrutura abastecimento                                                                            -
// Sub-Functions: None
// (00238000992024003A000B04120955010032000019071800B3CF890155F5B8A700320053)
//------------------------------------------------------------------------------------------------------------
Function LeRegistroComp(NumReg:integer):shortstring; stdcall; export;
var STReg:string[4];
    resposta:string;
    comando:string;
begin
  STReg:=inttostr(NumReg);
  while length(STReg)<4 do STReg:='0' + STReg;
  comando:=AdicionaCheck('(&LC' + copy(STReg,1,4));
  resposta:=Get('LeRegistro',comando,2000);
  result:=resposta;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeRegistroFid                                                                                      -
// Entrada: Nº do registro                                                                                   -
// Saída: Estrutura abastecimento                                                                            -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeRegistroFid(NumReg:integer):abastFid; stdcall; export;
var STReg:string[4];
    resposta:string[100];
    comando:string;
begin
  try
    STReg:=inttostr(NumReg);
    while length(STReg)<4 do STReg:='0' + STReg;
    comando:=AdicionaCheck('(&LR' + copy(STReg,1,4));
    resposta:=Get('LeRegistro',comando,1000);
    if (length(resposta)=74) then
      result:=StrToAbastFid(resposta)
    else
      result:=ABFidNill;
  except on e:exception do
  //  messagedlg(e.Message,mterror,[mbok],0);
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função ConfigFid                                                                                          -
// Entrada: Nº do registro                                                                                   -
// Saída: string de abastecimento                                                                            -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
procedure ConfigFid(canal,endereco:integer);stdcall; export;
var comando,resposta:string;
begin
  comando:=AdicionaCheck('(?CI0'+ inttostr(canal) + '0' + inttostr(endereco) + '05FE');
  resposta:=Get('ConfigFid',comando,1);
end;

//------------------------------------------------------------------------------------------------------------
// Função DesconfigFid                                                                                       -
// Entrada: Nº do registro                                                                                   -
// Saída: string de abastecimento                                                                            -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
procedure DesconfigFid(canal,endereco:integer);stdcall; export;
var stbico,comando,resposta:string;
    tentativa,bico:integer;
    erro:error;
begin
  comando:=AdicionaCheck('(?CI0'+ inttostr(canal) + '0' + inttostr(endereco) + '0000');
  resposta:=Get('DesconfigFid',comando,1);
  bico:=(canal*4) + (endereco-1);
  stbico:=inttohex(bico,2);
  erro:=AlteraModo(stbico,'L');
  tentativa:=1;
  while (erro<>none) and (tentativa<3) do
    begin
      erro:=AlteraModo(stbico,'L');
      inc(tentativa);
    end;
end;


//------------------------------------------------------------------------------------------------------------
// Função LeStRegistro                                                                                       -
// Entrada: Nº do registro                                                                                   -
// Saída: string de abastecimento                                                                            -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeStRegistro(NumReg:integer):ShortString; stdcall; export;
var STReg:string[4];
    resposta:string;
    comando:string;
begin
  STReg:=inttostr(NumReg);
  while length(STReg)<4 do STReg:='0' + STReg;
  comando:=AdicionaCheck('(&LR' + copy(STReg,1,4));
  resposta:=Get('LeStRegistro',comando,1000);
  if length(resposta)>=52 then
    result:=resposta
  else
    result:='FALHA';
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStRegistroFid                                                                                    -
// Entrada: Nº do registro                                                                                   -
// Saída: string de abastecimento                                                                            -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeStRegistroFid(NumReg:integer):ShortString; stdcall; export;
var STReg:string[4];
    resposta:string;
    comando:string;
begin
  STReg:=inttostr(NumReg);
  while length(STReg)<4 do STReg:='0' + STReg;
  comando:=AdicionaCheck('(&LR' + copy(STReg,1,4));
  resposta:=Get('LeStRegistro',comando,1000);
  if length(resposta)>=52 then
    result:=resposta
  else
    result:='FALHA';
end;



//------------------------------------------------------------------------------------------------------------
// Função AlteraPreco                                                                                        -
// Entrada: Nº do bico / novo preço                                                                          -
// Saída: Estrutura Error                                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function AlteraPreco(bico:string; preco:double; decimais:byte):error; stdcall; export;
var
  comando,resposta:string[75];
    //bicost:string;
    //len:integer;
begin
  AlteraPrecoNivel(bico, preco, decimais, 0);


  //comando := AdicionaCheck('(&U' + bico + '00' + formatafloat(preco,4,decimais));
  ////messagedlg(comando,mtinformation,[mbok],0);
  //resposta := Get('AlteraPreco',comando,2000);
  //Result := InformaErro(resposta,bico);
end;

Function AlteraPrecoNivel(bico:string; preco:double; decimais:byte; nivel:integer):error; stdcall; export;
var
  comando,resposta:string[75];
  //fPrice:string;
begin
  comando := AdicionaCheck('(&U' + bico + IntToStr(nivel) + '0' + formatafloat(preco,6,decimais));
  resposta := Get('AlteraPrecoNivel',comando,2000);
  Result := InformaErro(resposta,bico);
end;


Function AlteraPrecoComb(bico:string;preco:double;decimais:byte;tipo:Integer):error; stdcall; export;
var
  comando,resposta:string[75];
  //bicost:string;
  //len:integer;
  comb:string;
begin

  comb := IntToStr(tipo);
  comando:= AdicionaCheck('(&U' + bico + '0' + comb + formatafloat(preco,4,decimais));
  //messagedlg(comando,mtinformation,[mbok],0);
  resposta:=Get('AlteraPreco',comando,2000);
  Result:=InformaErro(resposta,bico);
end;

Function AlteraPrecoEstendidoNivel(bico:string;preco:double;decimais:byte;nivel:integer):error; stdcall; export;
var
  comando,resposta:string[75];
begin
  comando := AdicionaCheck('(&U' + bico + IntToStr(nivel) + '0' + FormataFloatToExtendedPrice(preco,8,decimais));
  resposta := Get('AlteraPrecoEstendidoNivel',comando,2000);
  Result := InformaErro(resposta,bico);
end;

//------------------------------------------------------------------------------------------------------------
// Função AlteraPreco                                                                                        -
// Entrada: Nº do bico / novo preço                                                                          -
// Saída: Estrutura Error                                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function SetPrice(bico:byte;preco:double;decimais:byte):error; stdcall; export;
var
  comando,resposta:string[75];
  bicost:string;
  //len:integer;
begin
  bicost:=inttohex(bico,2);
  comando:= AdicionaCheck('(&U' + bicost + '00' + formatafloat(preco,4,decimais));

  //messagedlg(comando,mtinformation,[mbok],0);

  resposta:=Get('AlteraPreco',comando,2000);
  Result:=InformaErro(resposta,bicost);
end;

//------------------------------------------------------------------------------------------------------------
// Função SetAlteraPreco                                                                                     -
// Entrada: Nº do bico / novo preço                                                                          -
// Saída: Estrutura Error                                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function SetAlteraPreco(st:string):boolean; stdcall; export;
var
  resposta,comando:string;
  bico:string[2];
  valor:string[4];
begin
  bico:=copy(st,1,2);
  valor:=copy(st,3,4);
  comando:=AdicionaCheck('(&U' + bico + '00' + valor);
  resposta:=Get('SetAlteraPreco',comando,2000);
  if InformaErro(resposta,bico)=None then
    result:=true
  else
    result:=false;
end;

//Function PresetVolume(bico:string; volume:double):Error; stdcall; export;
//var
  //str : string;
  //resposta:string;
  //comando:string;
//begin

//end;


//------------------------------------------------------------------------------------------------------------
// Função PresetValue                                                                                             -
// Entrada: Nº do bico, Valor do preset                                                                      -
// Saída: Estrutura Error                                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function PresetValue(bico:pchar;valor:integer):integer; stdcall; export;
var
  comando,resposta:string;
  stval:string[6];
begin
  stval:=inttostr(valor);
  while length(stval)<6 do stval:='0'+stval;
  comando:=AdicionaCheck('(&P' + bico + stval);
  resposta:=Get('Preset',comando,1000);
  if InformaErro(resposta,bico) = none then
    result:=1
  else
    result:=0;
end;

//------------------------------------------------------------------------------------------------------------
// Função Preset                                                                                             -
// Entrada: Nº do bico, Valor do preset                                                                      -
// Saída: Estrutura Error                                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function Preset2(bico:string;valor:double):Error; stdcall; export;
var
  comando,resposta:string;
  stval:string[6];
begin
  stval:=floattostr(valor);
  while length(stval)<6 do stval:='0'+stval;

  comando:=AdicionaCheck('(&P' + bico + stval);

  resposta:=Get('Preset',comando,1000);
  
  result:=InformaErro(resposta,bico);
end;

//------------------------------------------------------------------------------------------------------------
// Função Preset2                                                                                             -
// Entrada: Nº do bico, Valor do preset                                                                      -
// Saída: String com resposta do comando ou falha                                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function Preset(bico:byte;valor:PChar):ShortString; stdcall; export;
var
  comando,resposta, pValor, pBico:string;
  //pValor: AnsiString;
  //check: Integer;
begin
  pBico:=IntToHex(bico,2);
  pValor:= String(PChar(valor));

  while length(pValor)<6 do pValor := '0' + pValor;

  comando := AdicionaCheck('(&P' + pBico + pValor);
  resposta := Get('Preset',comando,1000);

  if resposta = 'FALHA' then
    result := 'FALHA'
  else
    Result := resposta;
end;

//---------------------------------------------------------------------------------------------------------------------
// Função PresetIdf                                                                                          -
// Entrada: Nº do bico, tag, código IDF, autoriza(S ou N), tipo de preset($ ou V), valor e tempo até retirar bico     -
// Saída: Estrutura Error                                                                                             -
// Sub-Functions: None                                                                                                -
// (?FBBPTTTTTTTTTTTTTTTTCAPPPPPPNNHRRRRRKK)                                                                          -
//---------------------------------------------------------------------------------------------------------------------
function presetIdf(bico: Byte; tag:AnsiString; frentista, autoriza, dinheiro: Boolean; valor: PChar; tempo: Integer):ShortString; stdcall; export;
var
  pBico, pTempo, pValor, comando, pLibera, pIdentificador, resposta: string;
  pTipo: string[1];
begin
  pBico := IntToHex(bico,2);
  pTempo := IntToStr(tempo);
  pValor := string(PChar(valor));

  while length(pValor)<6 do
    pValor := '0' + pValor;

  if frentista then
    pIdentificador := '0'
  else
    pIdentificador := '1';

  if autoriza then
    pLibera := 'S'
  else
    pLibera := 'N';

  if dinheiro then
    pTipo := '$'
  else
    pTipo := 'V';



  comando := AdicionaCheck('(?F' + pBico + 'P' + tag + pIdentificador + pLibera + pValor + pTempo + pTipo + '00000');
  //ShowMessage(comando);
  resposta := Get('PresetIdf',comando,2000);

  if resposta = 'FALHA' then
    Result := 'FALHA'
  else
    result := resposta;
end;

//------------------------------------------------------------------------------------------------------------
// Função PresetId                                                                                           -
// Entrada: Nº do bico, Valor do preset                                                                      -
// Saída: Estrutura Error                                                                                    -
// Sub-Functions: None                                                                                       -
// (?FBBPTTTTTTTTTTTTTTTTCAPPPPPPNNRRRRRRRRKK) 
//------------------------------------------------------------------------------------------------------------
Function PresetId(bico,tag:string;cliente,libera:boolean;valpreset,tempo:integer):boolean; stdcall; export;
var
  comando,resposta:string;
  stvalor:string[6];
  sttempo:string[2];
  tuser,autoriza:char;
begin
  bico:=copy(bico,1,2);
  tag:=copy(tag,1,16);

  if cliente then
    tuser:='C'
  else
    tuser:='F';

  if libera then
    autoriza:='S'
  else
    autoriza:='N';

  stvalor:=inttostr(valpreset);
  sttempo:=inttostr(tempo);

  while length(stvalor)<6 do
    stvalor:='0'+stValor;

  while length(sttempo)<2 do
    sttempo:='0'+sttempo;

  comando:=AdicionaCheck('(?F'+bico+'P'+tag+tuser+autoriza+stValor+stTempo+'00000000');
  resposta:=Get('Preset',comando,1000);
  
  result:= resposta = '(F'+bico+')';
end;

//------------------------------------------------------------------------------------------------------------
// Função SetPreset                                                                                          -
// Entrada: Nº do bico[2], Valor do preset[6]                                                                -
// Saída: Estrutura Error                                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function SetPreset(st:string):boolean; stdcall; export;
var
  comando,resposta:string;
  bico:string[2];
  valor:string[6];
begin
  bico:=copy(st,1,2);
  valor:=copy(st,3,6);

  comando:=AdicionaCheck('(&P' + bico + valor);
  resposta:=Get('SetPreset',comando,1000);

  if InformaErro(resposta,bico)=none then
    result:=true
  else
    result:=false;
end;


//------------------------------------------------------------------------------------------------------------
// Função LePPL                                                                                            -
// Entrada: Nº do bico                                                                                       -
// Saída: preço unitário : real                                                                              -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LePPL2(bicoint:integer):real; stdcall; export;
var
  comando,resposta:string;
  bico:string;
begin
  bico:=inttohex(bicoint,2);
  comando:=AdicionaCheck('(&T' + bico + 'U');
  resposta:=Get('LePPL',comando,2000);
  if length(resposta)=16 then
    result:=strtofloat(copy(resposta,10,4))
  else if resposta='DESCONECTADO' then
    result := -2
  else
    result := -1;
end;

//------------------------------------------------------------------------------------------------------------
// Função LePPL                                                                                            -
// Entrada: Nº do bico                                                                                       -
// Saída: preço unitário : real                                                                              -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LePPL3(par:pchar):integer; stdcall; export;
var
  comando,resposta:string;
  bico:string;
begin
  try
    bico:=copy(par,1,2);
    comando:=AdicionaCheck('(&T' + bico + 'U');
    resposta:=Get('LePPL3',comando,2000);
    if length(resposta)=16 then
      result:=strtoint(copy(resposta,10,4))
    else
      result:=0;
  except
    result:=0;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função ReadPriceLiterLevel0                                                                               -
// Entrada: Nº do bico                                                                                       -
// Saída: preço unitário : real                                                                              -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function ReadPriceLiterLevel0(nozzle:pchar):integer; stdcall; export;
var
  comando,resposta:string;
  bico:string;
begin
  try
    bico:=copy(nozzle,1,2);
    comando:=AdicionaCheck('(&T' + bico + 'u');
    resposta:=Get('ReadPriceLiterLevel0',comando,2000);
    if length(resposta)=20 then
      result:=strtoint(copy(resposta,10,4))
    else
      result:=0;
  except
    result:=0;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função ReadPriceLiterLevel1                                                                               -
// Entrada: Nº do bico                                                                                       -
// Saída: preço unitário : real                                                                              -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function ReadPriceLiterLevel1(nozzle:pchar):integer; stdcall; export;
var
  comando,resposta:string;
  bico:string;
begin
  try
    bico:=copy(nozzle,1,2);
    comando:=AdicionaCheck('(&T' + bico + 'u');
    resposta:=Get('ReadPriceLiterLevel1',comando,2000);
    if length(resposta)=20 then
      result:=strtoint(copy(resposta,6,4))
    else
      result:=0;
  except
    result:=0;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função ReadPriceLiterLevel2                                                                               -
// Entrada: Nº do bico                                                                                       -
// Saída: preço unitário : real                                                                              -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function ReadPriceLiterLevel2(nozzle:pchar):integer; stdcall; export;
var
  comando,resposta:string;
  bico:string;
begin
  try
    bico:=copy(nozzle,1,2);
    comando:=AdicionaCheck('(&T' + bico + 'u');
    resposta:=Get('ReadPriceLiterLevel2',comando,2000);
    if length(resposta)=20 then
      result:=strtoint(copy(resposta,14,4))
    else
      result:=0;
  except
    result:=0;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função LePPL                                                                                              -
// Entrada: Nº do bico                                                                                       -
// Saída: preço unitário : real                                                                              -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LePPL(bico:string):real; stdcall; export;
var
  comando,resposta:string;
begin
  comando:=AdicionaCheck('(&T' + bico + 'U');
  //messagedlg(comando,mtinformation,[mbok],0);
  resposta:=Get('LePPL',comando,2000);
  if length(resposta)=16 then
    result:=strtofloat(copy(resposta,10,4))
  else if resposta='DESCONECTADO' then
    result:=-2
  else
    result:=-1;
end;

Function LePPLNivel(bico:string; niveis: integer):PPLNivel; stdcall; export;
var
  comando,resposta:string;
  precos: PPLNivel;
begin
  if niveis = 1 then
  begin
    comando:=AdicionaCheck('(&T' + bico + 'U');
    resposta:=Get('LePPL',comando,2000);
    if length(resposta)=16 then
      precos.nivel0 := strtofloat(copy(resposta,10,4));
  end
  else if niveis = 2 then
  begin
    comando:=AdicionaCheck('(&T' + bico + 'U');
    resposta:=Get('LePPL',comando,2000);
    if length(resposta)=16 then
      precos.nivel0 := strtofloat(copy(resposta,10,4));
      precos.nivel1 := strtofloat(copy(resposta,6,4));
  end
  else if niveis = 3 then
  begin
    comando:=AdicionaCheck('(&T' + bico + 'u');
    resposta:=Get('LePPL',comando,2000);
    precos.nivel0 := strtofloat(copy(resposta,10,4));
    precos.nivel1 := strtofloat(copy(resposta, 6,4));
    precos.nivel2 := strtofloat(copy(resposta,14,4));
  end
  else
  begin
    precos.nivel0 := -1;
    precos.nivel1 := -1;
    precos.nivel2 := -1;
  end;
  result:=precos;
end;


//------------------------------------------------------------------------------------------------------------
// Função LeStringAb                                                                                         -
// Entrada: Nill                                                                                             -
// Saída: string                                                                                             -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeStringAb(var resposta:shortstring):shortstring;stdcall; export;
begin
  resposta:=Get('LeStringAb','(&A)',2000);
  result := resposta;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStatus                                                                                           -
// Entrada: None                                                                                             -
// Saída: variável estrutura                                                                                 -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeStStatus2:ShortString; stdcall; export;
var
  rta:ShortString;
begin
  rta:=Get('LeStStatus2','(&S)',2000);
  result:=rta;
end;

//------------------------------------------------------------------------------------------------------------
// Função STVisualizacao                                                                                     -
// Entrada: none                                                                                             -
// Saída: string lida da serial   (referência)                                                               -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function STVisualizacao(var visualizacao:ShortString):ShortString;stdcall; export;
begin
  Visualizacao:=Get('STVisualizacao','(&V)',800);
  Result:=Visualizacao;
end;

//------------------------------------------------------------------------------------------------------------
// Função Comunica                                                                                           -
// Entrada: nil                                                                                              -
// Saída: Bool                                                                                               -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function Comunica:boolean;stdcall; export;
var
  a:string;
  b:integer;
begin
  result := Alive;
  HRSSaveTAG('1234567812345678',4);
  HRSReadTAG(40,a,b);
end;

//------------------------------------------------------------------------------------------------------------
function SetUnitPrice(bico,price:pchar):integer;stdcall; export;
var
  comando,resposta:string;
begin
  if (length(bico)=2) and (length(price)=4) then
  begin
    comando:=AdicionaCheck('(&U' + bico + '00' + price);
    resposta:=Get('AlteraPreco',comando,2000);
    if resposta='(U'+bico+')' then
      result:=1
    else
      result:=0;
  end
  else
    result:=0;
end;




//------------------------------------------------------------------------------------------------------------
// Função LeStringAb                                                                                         -
// Entrada: Nill                                      teste                                                       -
// Saída: string                                                                                             -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure LeStringX(var resposta:retorno2);stdcall; export;
var
  ab:abast;
begin
  ab:=LeAbastecimento;
  if ab.value then
    resposta.value:=ab.st_full
  else
    resposta.value:='(0)';
end;

//------------------------------------------------------------------------------------------------------------
// Função RefEncerrante                                                                                      -
// Entradas: Bico,modo = $ ou L,variável por referência                                                      -
// Saída: Variável por referência                                                                            -
// sub-functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure RefEncerrante(bico:string;modo:char;var value:ShortString);stdcall; export;
var
  comando,resposta:string;
  rt:string;
begin
  bico:=copy(bico,1,2);
  if modo<>'$' then modo:='L';
  comando:=AdicionaCheck('(&T' + bico + modo);
  resposta:=Get('RefEncerrante',comando,2000);
  if length(resposta)=16 then
    rt:='(' + copy(resposta,4,2) + ')' + copy(resposta,6,6) + ',' + copy(resposta,12,2);
  value:=rt;
End;

// -----------------------------------------------------------------------------------------------------------
// Função RefAltPreco                                                                                        -
// Entrada: Nº do bico / novo preço / casas decimais / variável por referencia                               -
// Saída: variável status por referência                                                                     -
// Sub-Functions: None                                                                                       -
// -----------------------------------------------------------------------------------------------------------
Procedure RefAltPreco(bico:string;preco:double;decimais:byte;var status:error); stdcall; export;
var
  comando,resposta:string;
begin
  comando:=AdicionaCheck('(&U' + bico + '00' + formatafloat(preco,4,decimais));
  resposta:=Get('RefAltPreco',comando,2000);
  status:=InformaErro(Resposta,bico);
end;

//------------------------------------------------------------------------------------------------------------
// Função STRefAltPreco                                                                                      -
// Entrada: Nº do bico / novo preço / casas decimais / variável por referencia                               -
// Saída: variável status por referência                                                                     -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function STRefAltPreco(par:ShortString):integer; stdcall; export;
var
  comando,resposta:string;
begin
  comando:=AdicionaCheck('(&U' + par);
  resposta:=Get('STRefAltPreco',comando,2000);
  if InformaErro(Resposta,copy(par,1,2))=None then result:=1 else result:=0;
end;

//------------------------------------------------------------------------------------------------------------
// Função RefBloqueiaBico                                                                                    -
// Entrada: Nº do bico ou '00' para todas bombas                                                             -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure RefBloqueiaBico(bico:string;var status:error); stdcall; export;
begin
  status:=AlteraModo(bico,'B');
end;

//------------------------------------------------------------------------------------------------------------
// Função RefAutorizaAbast                                                                                   -
// Entrada: Nº do bico ou '00' para todas bombas                                                             -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure RefAutorizaAbast(bico:string;var status:error); stdcall; export;
begin
  status:=AlteraModo(bico,'A');
end;

//------------------------------------------------------------------------------------------------------------
// Função RefAutoLibera                                                                                      -
// Entrada: Nº do bico '00' p/ todas bombas                                                                  -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure RefAutoLibera(bico:string;var status:error); stdcall; export;
begin
  status:=AlteraModo(bico,'L');
end;

//------------------------------------------------------------------------------------------------------------
// Função RefParaBomba                                                                                       -
// Entrada: Nº do bico '00' p/ todas bombas                                                                  -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure RefParaBomba(bico:string;var status:error); stdcall; export;
begin
  status:=AlteraModo(bico,'S');
end;

//------------------------------------------------------------------------------------------------------------
// Função RefLePPL                                                                                           -
// Entrada: Nº do bico                                                                                       -
// Saída: preço unitário : real                                                                              -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure RefLePPL(bico:string;var value:ShortString); stdcall; export;
var
  resposta:string[16];
  comando:string[10];
  rt:string;
begin
  comando:=AdicionaCheck('(&T' + bico + 'U');
  resposta:=Get('RefLePPL',comando,2000);
  if length(resposta)=16 then rt:=copy(resposta,10,4);
  value:=rt;
end;

//------------------------------------------------------------------------------------------------------------
// Função RefPreset                                                                                          -
// Entrada: Nº do bico, Valor do preset , variável por referência                                            -
// Saída: Estrutura Error                                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure RefPreset(bico:string;valor:double;var status:error); stdcall; export;
var comando,resposta:string;
    stval:string[6];
begin
  stval:=floattostr(valor);
  while length(stval)<6 do stval:='0'+stval;
  comando:=AdicionaCheck('(&P' + bico + stval);
  resposta:=Get('RefPreset',comando,1000);
  status:=InformaErro(resposta,bico);
end;

//------------------------------------------------------------------------------------------------------------
// Função LePart                                                                                             -
// Entrada: L-litros, T-total, P-ppl, E-tempo                                                                -
// Saída: BB-<resultado do pedido>                                                                           -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LePart(option:char):ShortString; stdcall; export;
var st_rta,resposta:string;
begin
  resposta:=Get('LePart','(&A)',1000);
  if ((length(resposta)=34) or (length(resposta)=52)) and (resposta<>'(0)') then
    begin
      if option='L' then
        st_rta:=copy(resposta,24,2) + '-' + copy(resposta,8,6)
      else if option='T' then
        st_rta:=copy(resposta,24,2) + '-' + copy(resposta,2,6) else
      if option='P' then
        st_rta:=copy(resposta,24,2) + '-' + copy(resposta,14,4) else
      if option='C' then
        st_rta:=copy(resposta,24,2) + '-' + copy(resposta,26,2) + '/' + copy(resposta,28,2) + ':' + copy(resposta,30,2) else
      if option='E' then
        st_rta:=copy(resposta,24,2) + '-' + copy(resposta,20,4);
      result:=st_rta;
    end
  else
    result:='00-000000';
end;



//------------------------------------------------------------------------------------------------------------
// Função FOXLePPL                                                                                           -
// Entrada: Nº do bico ('BB')                                                                                -
// Saída: preço unitário:string ('0000')                                                                     -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function FOX_LePPL(bico:string):integer; stdcall; export;
var resposta:string[16];
    comando:string[10];
    //stBico:string[2];
    //res:integer;
begin
  bico:=copy(bico,1,2);
  comando:=AdicionaCheck('(&T' + Bico + 'U');
  resposta:=Get('FoxLePPL',comando,2000);
  if length(resposta)=16 then
    result:=strtoint(copy(resposta,10,4))
  else
    result:=0;
end;

//------------------------------------------------------------------------------------------------------------
// Função AlteraPreco                                                                                        -
// Entrada: Nº do bico / novo preço                                                                          -
// Saída: Estrutura Error                                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function FOX_GravaPPL(bico,preco:string):integer; stdcall; export;
var comando,resposta:string[75];
begin
  comando:= AdicionaCheck('(&U' + bico + '00' + preco);
  resposta:=Get('AlteraPreco',comando,2000);
  if resposta='(U' + bico + ')' then
    result:=1
  else
    result:=0;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStatus                                                                                           -
// Entrada: None                                                                                             -
// Saída: variável estrutura                                                                                 -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeStStatus:StStatus; stdcall; export;
var a:ststatus;
begin
  a.value:=Get('LeStStatus','(&S)',800);
  result:=a;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStructPPL                                                                                        -
// Entrada: Bico                                                                                             -
// Saída: variável estrutura PPL/Bico                                                                        -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeStructPPL(bico:string):stPPL; stdcall; export;
var comando,resposta:string[50];
begin
  comando:=AdicionaCheck('(&T' + bico + 'U');
  Resposta:=Get('LeStructPPL',comando,2000);
  if length(resposta)=16 then
    begin
      Result.Bico:=copy(resposta,4,2);
      Result.PPL:=copy(resposta,10,4);
    end
  else if resposta='DESCONECTADO' then
    begin
      result.Bico:='00';
      result.PPL:='9999';
    end
  else
    begin
      Result.Bico:='99';
      Result.PPL:=resposta;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStructEncerrante                                                                                 -
// Entrada: Bico,Tipo                                                                                        -
// Saída: variável estrutura Bico/Tipo/Enc                                                                   -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeStructEncerrante(modo:string;bico:string):stEncerrante; stdcall; export;
var comando,resposta:string[50];
begin
  //messagedlg('bico: ' + bico,mtinformation,[mbok],0);
  //messagedlg('modo: ' + modo,mtinformation,[mbok],0);
  comando:=AdicionaCheck('(&T' + bico + modo[1]);
  Resposta:=Get('LeStructEncerrante',comando,3000);
  if length(Resposta)=16 then
    begin
      Result.Bico:=copy(resposta,4,2);
      Result.Encerrante:=copy(resposta,6,8);
    end
  else if length(Resposta)=18 then
    begin
      Result.Bico:=copy(resposta,4,2);
      Result.Encerrante:=copy(resposta,6,10);
    end
  else if resposta='DESCONECTADO' then
    begin
      Result.Bico:='00';
      Result.Encerrante:='99999999';
    end
  else
    begin
      Result.Bico:='99';
      Result.Encerrante:='99999999';
    end;
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStructEncerrante                                                                                 -
// Entrada: Bico,Tipo                                                                                        -
// Saída: variável estrutura Bico/Tipo/Enc                                                                   -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeStructEncerrante2(modo:string;bico:string):stEncerrante2; stdcall; export;
var comando,resposta:string[50];
begin
  comando:=AdicionaCheck('(&T' + bico + modo[1]);
  Resposta:=Get('LeStructEncerrante',comando,3000);
  //messagedlg('retorno: ' + resposta,mtinformation,[mbok],0);
  if length(Resposta)=16 then
    begin
      Result.Bico:=copy(resposta,4,2);
      Result.Encerrante:=copy(resposta,6,8);
    end
  else if length(Resposta)=18 then
    begin
      Result.Bico:=copy(resposta,4,2);
      Result.Encerrante:=copy(resposta,6,10);
    end
  else if resposta='DESCONECTADO' then
    begin
      Result.Bico:='00';
      Result.Encerrante:='99999999';
    end
  else
    begin
      Result.Bico:='99';
      Result.Encerrante:='99999999';
    end;
end;

//------------------------------------------------------------------------------------------------------------
// Função teste                                                                                              -
// Entrada: void                                                                                             -
// Saída: Classe TSAbastecimento                                                                             -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function teste:ShortString;stdcall; export;
begin
  result:=Get('LeStReduzida','(&A)',1000);
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStReduzida                                                                                       -
// Entrada: none                                                                                             -
// Saída: BBTTTTTTEEEEEEEEEE                                                                                 -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeStReduzida:ShortString;stdcall; export;
var Resposta:string;
begin
  Resposta:=Get('LeStReduzida','(&A)',1000);
  if resposta='(0)' then
    result:='(0)'
  else if copy(resposta,2,12)='000000000000' then
    begin
      incrementa;
      result:='(0)';
    end
  else if (length(resposta)=34) or (length(resposta)=52) then
    begin
      incrementa;
      result:=copy(Resposta,24,2) + copy(Resposta,8,6) + copy(Resposta,38,10);
    end
  else result:='(0)';
end;

//------------------------------------------------------------------------------------------------------------
//                                                                                                           -
//------------------------------------------------------------------------------------------------------------
function LeEvento(indice:integer):shortstring; stdcall; export;
var comando,resposta:string;
    stReg:string;
begin
  stReg:=inttostr(indice);
  while length(stReg)<4 do stReg:='0' + stReg;
  comando:=AdicionaCheck('(&LL' + stReg);
  resposta:=Get('LeEvento',comando,1000);
  result:=resposta;
end;

//------------------------------------------------------------------------------------------------------------
Function GetIdentTag:ShortString; stdcall; export;
var comando,resposta:string;
    st : string;
begin
  comando := AdicionaCheck('(?A');
  resposta := Get('GetIdentTag', comando , 1000);

  //ShowMessage(comando);

  if resposta = '(0)' then
    result := '0'
  else
  begin
    st := copy(resposta , 3 , 16 );
    st := st + ';';
    st := st + copy(resposta ,    19, 2 );
    result := st;
  end;
end;

//------------------------------------------------------------------------------------------------------------
Function FidIdent:IFid; stdcall; export;
var comando,resposta:string;
    rta:IFid;
begin
  comando:=AdicionaCheck('(?A');
  resposta:=Get('LeFidIdent',comando,1000);
  rta.value:=false;
  if length(resposta)=37 then
    begin
      rta.value:=true;
      rta.Codigo:=copy(resposta,3,16);
      rta.Endereco:=copy(resposta,19,2);
      rta.Dia:=copy(resposta,21,2);
      rta.Hora:=copy(resposta,23,2);
      rta.Minuto:=copy(resposta,25,2);
      rta.Mes:=copy(resposta,27,2);
      rta.Registro:=strtoint(copy(resposta,29,4));
      rta.StFull:=resposta;
      if copy(resposta,31,2)='00' then rta.Status:=true else rta.Status:=false;
    end
  else if resposta='(0)' then
    begin
      rta.value:=true;
      rta.Codigo:='0';
      rta.Endereco:='0';
      rta.Dia:='0';
      rta.Hora:='0';
      rta.Minuto:='0';
      rta.Mes:='0';
      rta.Registro:=0;
      rta.StFull:=resposta;
      rta.Status:=false;
    end;
  result:=rta;
end;

//------------------------------------------------------------------------------------------------------------
//                                                                                                           -
//                                                                                                           -
//------------------------------------------------------------------------------------------------------------
Function FidStatus:StFid; stdcall; export;
var comando:string;
    resposta:string[75];
    rta:StFid;
begin
  comando:=AdicionaCheck('(?S');
  resposta:=Get('LeFidStatus',comando,1000);
  if length(resposta)>=34 then
    rta.Status:=copy(resposta,3,32)
  else
    rta.Status:='SEM RESPOSTA';
  result:=rta;
end;

//------------------------------------------------------------------------------------------------------------
//                                                                                                           -
//                                                                                                           -
//------------------------------------------------------------------------------------------------------------
Procedure FidIncrementa;stdcall; export;
var comando:string;
begin
  comando:=AdicionaCheck('(?I');
  Get('IncrementaFid',comando,1);
end;


//------------------------------------------------------------------------------------------------------------
//                                                                                                           -
//                                                                                                           -
//------------------------------------------------------------------------------------------------------------
Function FidModo(endereco:string;option:char):integer;stdcall; export;
var resposta,comando:string[75];
begin
  comando:=AdicionaCheck('(?M' + endereco + option);
  resposta:=Get('FidModo',comando,800);
  if resposta='(M' + endereco + ')' then  result:=1       // 1- comando Ok
  else if resposta='(M?t)' then result:=2                 // 2- erro timeout
  else if resposta='(M?b)' then result:=3                 // 3- erro endereco
  else if resposta='(M?m)' then result:=4                 // 4- erro caracter modo
  else result:=0;                                         // 0- erro desconhecido
end;

//------------------------------------------------------------------------------------------------------------
//                                                                                                           -
//                                                                                                           -
//------------------------------------------------------------------------------------------------------------
Function FidAciona(endereco:string;minutos,segundos:byte):integer; stdcall; export;
var stminuto,stsegundo:string[2];
    comando,resposta:string[50];
begin
  if minutos<10 then stminuto:='0' + inttostr(minutos) else stminuto:=inttostr(minutos);
  if segundos<10 then stsegundo:='0' + inttostr(segundos) else stsegundo:=inttostr(segundos);
  if length(endereco)<2 then endereco:='0' + endereco;
  comando:=AdicionaCheck('(?P' + endereco + stminuto + stsegundo);
  resposta:=Get('FidAciona',comando,800);
  if resposta='(P' + endereco + ')' then  result:=1       // 1- comando Ok
  else if resposta='(P?t)' then result:=2                 // 2- erro timeout
  else if resposta='(P?b)' then result:=3                 // 3- erro endereco
  else if resposta='(P?m)' then result:=4                 // 4- erro caracter modo
  else result:=0;                                         // 0- erro desconhecido
end;

//------------------------------------------------------------------------------------------------------------
//                                                                                                           -
//                                                                                                           -
//------------------------------------------------------------------------------------------------------------
Function FidSetClock(dia,hora,minuto:byte):integer;stdcall; export;
var stdia,sthora,stminuto:string[2];
    comando,resposta:string;
begin
  if dia<10 then stdia:='0' + inttostr(dia) else stdia:=inttostr(dia);
  if hora<10 then sthora:='0' + inttostr(hora) else sthora:=inttostr(hora);
  if minuto<10 then stminuto:='0' + inttostr(minuto) else stminuto:=inttostr(minuto);
  comando:='(?H' + stdia + sthora + stminuto + ')';
  resposta:=Get('FidSetClock',comando,800);
  if resposta='(%H)' then
    result:=1                                           // 1- comando Ok
  else
    result:=0;                                          // 0- falha
end;

//------------------------------------------------------------------------------------------------------------
Function FidLeRegistro(nro:integer):ShortString;stdcall; export;
var stnro:string[4];
    resposta,comando:string;
begin
  stnro:=inttostr(nro);
  while length(stnro)<6 do stnro:='0' + stnro;
  comando:=AdicionaCheck('(?LF' + stnro);
  resposta:=Get('LeFidRegistro',comando,1000);
  result:=resposta;
end;

//------------------------------------------------------------------------------------------------------------
Function IIILeAbast(var st:string):ShortString;
var comando,resposta:string;
begin
  comando:=AdicionaCheck('(&A');
  resposta:=Get('LeFid2Abast',comando,1000);
  result:=resposta;
end;

//------------------------------------------------------------------------------------------------------------
Function PortOpen:boolean;stdcall;export;
begin
  result:=ioPortOpen;
end;

//------------------------------------------------------------------------------------------------------------
Function SocketOpen:boolean;stdcall;export;
begin
  result:=ioSocketOpen;
end;

//------------------------------------------------------------------------------------------------------------
function SendReceiveText(var st:PAnsiChar;timeout:integer):integer;stdcall; export;
var
  resposta:string;
begin
  resposta:=Get('SendText',st,timeout);
  st:=pchar(resposta);
  result:=0;
end;

//------------------------------------------------------------------------------------------------------------
function PB_sendReceiveText(var st: WideString; timeout: Integer):Integer; stdcall; export;
var
  //resposta: string;
  rec,comando:string;
  a:integer;
begin
  for a:=1 to length(st) do if st[a]=')' then break;
  comando:=copy(st,1,a);
  if timeout<1000 then timeout:=1000;
  rec:=Get('VB_SendReceiveText',comando,timeout);
  st:=rec;
  result:=length(rec);
end;
//------------------------------------------------------------------------------------------------------------
Function ADVPL_ReadSale(var st:pchar):integer;stdcall; export;
var
  rec:string;
begin
  rec:=Get('VB_ReadAbastecimento','(&A)',1000);
  //messagedlg(rec,mtinformation,[mbok],0);
  if (length(rec)=52) or (length(rec)=34) then
    begin
      st:=pchar(rec);
      result:=1;
    end
  else
    if rec='(0)' then
      begin
        st:=pchar(rec);
        result:=2;
      end
    else
      begin
        st:=pchar('');
        result:=0;
      end;
end;




//------------------------------------------------------------------------------------------------------------
function ADVPL_ReadState(var st:pchar):integer;stdcall; export;
var
  rec:string;
begin
  rec:=Get('VB_ReadState','(&S)',1000);
  if length(rec)=51 then
    begin
      st:=pchar(rec);
      result:=1;
    end
  else
    begin
      st:=pchar('');
      result:=0;
    end;
end;

//------------------------------------------------------------------------------------------------------------
procedure FOX_ReadState(var r:retorno);stdcall; export;
begin
  r.value:=Get('ConsultaStatus','(&S)',3000);
end;

//------------------------------------------------------------------------------------------------------------
function SetFullClock(dia,mes,ano,hora,minuto:integer):integer;stdcall; export;
var
  stdia,stmes,sthora,stminuto:string[2];
  stano:string[4];
  comando,resposta:string;
  tentativas:byte;
begin
  if parseDate(hora,minuto,dia,mes,ano) then
    begin
      if hora<10 then
        sthora:='0' + inttostr(hora)
      else
        sthora:=inttostr(hora);

      if minuto<10 then
        stminuto:='0' + inttostr(minuto)
      else
        stminuto:=inttostr(minuto);

      if dia<10 then
        stdia:='0' + inttostr(dia)
      else
        stdia:=inttostr(dia);

      if mes<10 then
        stmes:='0' + inttostr(mes)
      else
        stmes:=inttostr(mes);

      stano:=inttostr(ano);

      if length(stano)=4 then
        stano:=copy(stano,3,2);
      resposta:='';

      while (resposta<>'(&H)') and (tentativas<3) do
        begin
          comando:='(&H'+stdia + sthora + stminuto+')';
          resposta:=Get('CLK',comando,500);
          inc(tentativas);
        end;

      if resposta='(&H)' then
        begin
          comando:=AdicionaCheck('(&CH02' + stdia + stmes + stano);
          resposta:=Get('CLK',comando,0);
          result:=1;
        end
      else
        result:=0;
    end
  else
    result:=2;
end;


//-------------------------------------- teste pchar


function testepchar(texto:pchar):pchar;stdcall;export;
var
  str:string;
  resposta:string;
  //resp:pchar;
begin
    str := texto;
    resposta :=Get('GetAbastecimento',str,1000);
    result := pchar(resposta + #0);
    {if resposta[length(resposta)] = ')' then
    begin
      //messagedlg(resposta,mterror,[mbok],0);
      resp:= pchar(resposta + ' ');
      messagedlg(pchar(sizeof(resp)),mterror,[mbok],0);
      result := resp;
     end else
           messagedlg('erro bizarro',mterror,[mbok],0);    }

end;

//


//------------------------------------------------------------------------------------------------------------
//                                                                                                           -
// GETS                                                                                                      -
//                                                                                                           -
//------------------------------------------------------------------------------------------------------------
function GetAbastecimento:shortstring;stdcall;export;
begin
  result:=Get('GetAbastecimento','(&A)',1000);
end;

function XEGetAbastecimento:string;stdcall;export;
begin
  result:=Get('GetAbastecimento','(&A)',1000);
end;

function GetAbastecimentoIdent:shortstring;stdcall;export;
var comando:string;
begin
  comando:=adicionacheck('(&A');
  result:=Get('GetAbastecimentoIdent',comando,1000);
end;

function GetAbastecimento2Ident:shortstring;stdcall;export;
var comando:string;
begin
  comando:=adicionacheck('(&@');
  result:=Get('GetAbastecimentoIdent',comando,1000);
end;

function GetEncerrante(bico:string;tipo:char):shortstring;stdcall;export;
var comando:string;
begin
  comando:=adicionacheck('(&T'+bico+tipo);
  result:=Get('GetEncerrante',comando,2000);
end;

function GetRegistro(nreg:integer):shortstring;stdcall;export;
var comando:string;
    stnReg:string;
begin
  if (nreg>=0) and (nreg<=9999) then
    begin
      stnReg:=inttostr(nreg);
      while length(stnReg)<4 do stnReg:='0'+stnReg;
      comando:=adicionacheck('(&LR' + stnReg);
      result:=get('GetRegistro',comando,500);
    end
  else result:='';
end;

function GetVisualizacao:shortstring;stdcall;export;
begin
  result:=Get('GetVisualizacao','(&V)',1000);
end;

function GetVisualizacaoId:shortstring;stdcall;export;
begin
  result:=Get('GetVisualizacaoId','(?V95)',1000);
end;

function Connected:boolean;stdcall;export;
begin
  result:=ioConnected;
end;


//----------------------------------------------------------------------------------------------------------------------------------
function EscLog(ent,arquivo: string):boolean;
var F: textfile;
    a: integer;
begin
  result:=false;
  try
    if fileexists(arquivo) then
      begin
        assignfile(F, arquivo);
        append(F);
        writeln(f,ent);
        result:=true;
        CloseFile(F);
      end
    else
      begin
        a:=filecreate(arquivo);
        if a<>-1 then
          begin
            fileclose(a);
            assignfile(F, arquivo);
            append(F);
            writeln(f,ent);
            result:=true;
            CloseFile(F);
          end;
      end;
  except
    result:=false;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// 0 = não conseguiu gravar
// 1 = sucesso
// 2 = sem abastecimentos
// 3 = erro desconhecido
//------------------------------------------------------------------------------------------------------------
function XH_AbastToFile(path:shortstring):integer;stdcall; export;
var rta:string;
    //F:textfile;
begin
  try
    //messagedlg('PATH:' + path,mtinformation,[mbok],0);
    rta:=Get('GetAbastecimento','(&A)',2000);
    //messagedlg('RTA:' + rta,mtinformation,[mbok],0);
    if length(rta)>=52 then
      begin
        if EscLog(rta,path) then
          result:=1
        else
          result:=0;
      end
    else
      result:=2;
  except
    result:=3;
  end;
end;

function XH_AbastDuplaIdentToFile(path:shortstring):integer;stdcall; export;
var rta:string;
begin
  try
    rta := Get('GetAbastecimentoDuplaIdentif','(&@66)',2000);
    if length(rta) >= 87 then
      begin
        if EscLog(rta,path) then
          result := 1
        else
          result := 0;
      end
    else
      result := 2;
  except
    result := 3;
  end;
end;

// -------------------------------------------------------------------------------------------------------------------------------------------
// ATC Functions
// -------------------------------------------------------------------------------------------------------------------------------------------
// i201011308091504010000007 451EFBA4 451E56C7 4538C4B2 420865FF ???????? 428384F8 00000000 &&EE48<ETX>
// i201011308131358010000007 468B25EB 468AB7AF 453C0E2D 430E47A6 ???????? 419001A1 00000000 &&EE47<ETX>
// i201011308091746010000007 4616739A 4615D528 462EDBC7 42AD3954 ???????? 41967114 00000000 &&E
//       YYMMDDHHmmttpssssNN     Vol    TC       Ullage  Height   Water     Temp    Water V
// 1234567890123456789012345 678901234567890123456789012345678901234567890123456789012345678901234567
// 0        1         2          3         4         5         6         7         8         9
// -------------------------------------------------------------------------------------------------------------------------------------------
// TLS-250
// -------------------------------------------------------------------------------------------------------------------------------------------
//    MMDDHHmmsssTPssssHHHhhGGGGGGSTTTtUUUUUUWWt
// 100090215270001011001237901339000227005702254201101?????????????????????????9EFA2
// 1234567890123456789012345678901234567890123456789012345678901234567890123456789012
// 0        1         2         3         4         5         6         7         8
// -------------------------------------------------------------------------------------------------------------------------------------------
Function ATCInventoryReport(tank:integer;var inventory:TInventory):integer;stdcall; export;
var tanque:shortstring;
    comando,resposta:ansistring;
begin
  try
    if (ATCSerialIsConnected) or (ATCSocketIsConnected) then
      begin
        tanque:=inttostr(tank);
        while length(tanque)<2 do tanque:='0' + tanque;
        comando:='i201' + tanque;
        if tanque>='100' then
          resposta:='i2010113080917460100000074616739A4615D528462EDBC742AD3954????????4196711400000000&&E'
        else
          //resposta:=writeATCSerial(comando);
          resposta:=ATCSendReceiveText(comando);
        if length(resposta)>=84 then                        // TLS-350 Protocol
          begin
            inventory:=strToATCInventory(resposta);
            result:=length(inventory.FullString);
          end
        else if length(resposta)=82 then                    // TLS-250 Protocol
          begin
            inventory.Calendario:=copy(resposta,8,2)+':'+copy(resposta,10,2)+' '+copy(resposta,6,2)+'/'+copy(resposta,4,2)+'/'+ formatdatetime('yy',now);
            inventory.Tanque:='0'+resposta[15];
            inventory.Produto:=resposta[16];
            inventory.Heigth:=copy(resposta,21,3)+'.'+copy(resposta,24,2);
            inventory.Volume:=copy(resposta,26,6);
            if resposta[32]='0' then
              inventory.Temperatura:=copy(resposta,34,2)+'.'+resposta[36]
            else
              inventory.Temperatura:='-' + copy(resposta,34,2)+'.'+resposta[36];
            
            inventory.Ullage:=copy(resposta,37,6);
            inventory.Water:=copy(resposta,43,2)+'.'+resposta[45];
            inventory.FullString:=resposta;
            result:=length(inventory.FullString);
          end
        else
          result:=-1;                                       // resposta inválida
      end
    else
      result:=0;                                          // porta não aberta
  except on e:exception do
    result:=-2;
  end;
end;

// -------------------------------------------------------------------------------------------------------------------------------------------
Function ATCInventoryString(tank:integer;var inventory:string):integer;stdcall; export;
var tanque:shortstring;
    comando,resposta:ansistring;
begin
  try
    if (ATCSerialIsConnected) or (ATCSocketIsConnected) then
      begin
        tanque:=inttostr(tank);
        while length(tanque)<2 do tanque:='0' + tanque;
        comando:='i201' + tanque;
        if tanque>='100' then
          resposta:='i2010113080917460100000074616739A4615D528462EDBC742AD3954????????4196711400000000&&E'
        else
          resposta:=ATCSendReceiveText(comando);
        inventory:=resposta;
        result:=strtoint(inventory);
      end;
  except on e:exception do
    result:=0;
  end;
end;


// -------------------------------------------------------------------------------------------------------------------------------------------
// Comando : (&T99N3A)
// Resposta: (T4990000022280)
//           1234567890123456
// -------------------------------------------------------------------------------------------------------------------------------------------
// Comando : >?00021264
// Resposta: >!006F12B01.00 F05.09 25/07/13 0 12,96 2 0110 4-00000222 06/08/12 08/08/13 00:26:28:00:02:22 192.168.0.95;17/11/13 Fc5A
//           123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
//                    1         2         3         4         5         6
// Comando : (&S)
// Resposta: (SFFFFFFFFFFFFFFFFBBFFFFFFFFFFFFFFFFFF6V5.9M1.0G83)
// -------------------------------------------------------------------------------------------------------------------------------------------

function GetConsoleVersion(var version:pchar):integer;stdcall; export;
var resposta,resposta2:string; //comando
    tipo:byte;
    modelo:string;
    nroSerie:integer;
begin
  try
    resposta:=Get('GetConsoleVersion','(&T99N3A)',2000);
    if (length(resposta)=16) and (copy(resposta,4,2)='99') then
      begin
        tipo:=strtoint('$' + resposta[3]);
        nroSerie:=strtoint(copy(resposta,6,8));
        modelo:='';
        case tipo of
          48..57: modelo:='1,HORUS,' + inttostr(nroSerie) + ',1;';
          65..90: begin
            modelo:='2,CBC/GNV,' + inttostr(nroSerie);
            resposta2:=Get('GetConsoleVersion','(&S)',2000);
            if length(resposta2)>=48 then
              modelo:=modelo + ',' + resposta2[39] + ';'
            else
              modelo:=modelo + ',' + '0' + ';'
          end;
          97..122: begin
            modelo:='3,CBC,' + inttostr(nroSerie);
            resposta2:=Get('GetConsoleVersion','(&S)',2000);
            if length(resposta2)>=48 then
              modelo:=modelo + ',' + resposta2[39] + ';'
            else
              modelo:=modelo + ',' + '0' + ';'
          end;
        end;
      end
    else
      begin
        resposta:=Get('GetConsoleVersion','>?00021264',2000);
        if (length(resposta)>=57) and (copy(resposta,1,2)='>!') then
          begin
            nroSerie:=strtoint(copy(resposta,49,8));
            modelo:='1,HORUS,' + inttostr(nroSerie) + ',1;';
          end
        else
        begin
          resposta:=Get('GetConsoleVersion','(&S)',2000);
          if length(resposta)=15 then
            modelo:='3,CBC,' + '0,1;'
          else if length(resposta)=48 then
            begin
            resposta2:=Get('GetConsoleVersion','(&T99N3A)',2000);
            if length(resposta2)=16 then
              nroSerie:=strtoint(copy(resposta2,6,8))
            else
              nroserie:=0;
            modelo:='3,CBC,' + inttostr(nroSerie)  + ',' + resposta[39] + ';'
          end;
        end;
      end;
    version:=Pchar(modelo);
    result:=strtoint(modelo[1]);
  except on e:exception do
    begin
      version:=Pchar(e.Message);
      result:=-1;
    end;
  end;
end;

procedure timerEvent(sender :tobject);
begin
//messagedlg('sdfsd',mterror,[mbok],0);
end;


// -----------------------------------------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------------------------------------
procedure TestCallBack(clientFunc: TCallBackFunction);
//var ab:string;
begin
  while true do
    begin
      sleep(1000);
      clientFunc(123);
    end;
end;


// -----------------------------------------------------------------------------------------------------------
// EVENTOS                                                                                                   -
// -----------------------------------------------------------------------------------------------------------
procedure DLL_Load;
begin
  ThousandSeparator:='.';
  DecimalSeparator:=',';
  ShortDateFormat:='dd/MM/yyyy';
  CurrencyString:='R$';
  CurrencyDecimals:=2;
  DateSeparator:='/';
  TimeSeparator:=':';
  ShortTimeFormat:='hh:mm';
  LongTimeFormat:='hh:mm:ss';
  try
    CreateSocket;
    CreateATCSerial;
    CreateSerial;
    Ver(Version);
    CreateTrayIcon('DLLCompanytec Vr. ' + Version.versao);
  except on e:exception do
    //messagedlg(e.Message,mterror,[mbok],0);
  end;
end;

function teste2(var st:string):integer;
begin
  st:='teste';
  result:=1;
end;

// -----------------------------------------------------------------------------------------------------------
procedure DLL_Unload;
begin
  try
    DestroyTrayIcon;
    DestroySocket;
    DestroySerial;
    DestroyATCSerial;
  except
  end;
end;

// -----------------------------------------------------------------------------------------------------------
procedure LibraryProc(dwReason:integer);
begin
  case dwReason of
    DLL_PROCESS_ATTACH: DLL_Load;
    DLL_PROCESS_DETACH: DLL_Unload;
  end;
end;

//------------------------------------------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////////
//
//
//          BEGIN        C_funtions
//
//
/////////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------------------------------------------------------------
//Function C_GetSale(var p:pstring):integer; stdcall; export;
//var resposta:string;
//    comando:string[7];
//begin
//try
//comando:='(&A299)';
//resposta:=Get('LeAbastecimentoPAF1',comando,3000);
//if (length(resposta)=123) then
//    begin
//    result:=1;
//    p:=pstring(resposta);
//    end
//else
//  begin
//  result:=0;
//  p:=pstring(' ');
//  end;
//except
//  result:=-1;
//end;
//end;
//--------------------------------------------------------------------------------------------------------------------------------

function C_OpenSerial(np:integer):integer; stdcall; export;
begin
  if InicializaSerial(np) then result:=1 else result:=0;
end;

Function C_CloseSerial:integer;stdcall; export;
begin
    result := FechaSerial;
end;

function  C_OpenSocket(ip:pchar):integer; stdcall; export;
var
   str:string;
begin
    str := ip;
    result := VB_OpenSocket(str);
end;


function C_OpenSocket2(ip:pchar; port:integer ):integer; stdcall;export;
begin
  if InicializaSocket2(ip,port) then result:=1 else result:=0;
end;

function C_CloseSocket:integer;stdcall; export;
begin
    if FechaSocket then result:=1 else result:=0;
end;

Function C_GetSale():pchar; stdcall; export;
var
    resposta:string;
    comando:string[7];
begin
  try
    comando:='(&A)';
    resposta:=Get('LeAbastecimento',comando,3000);
    if (length(resposta)=34) or (length(resposta)=52) then
    begin
      result := pchar(resposta + #0);
    end
    else
    begin
      result := pchar('(0)' + #0);
    end;
  except
    result := pchar('ERROR' + #0);
  end;
end;
//------------------------------------------------------------------------------------------------------------
Function C_GetSalePAF():pchar; stdcall; export;
var
  resposta:string;
  comando:string[7];
begin
  try
    comando := '(&A299)';
    resposta := Get('LeAbastecimentoPAF1',comando,3000);
    if(length(resposta)=123) then
      begin
        result := pchar(resposta + #0);
      end
    else
    begin
      result := pchar('(0)' + #0);
    end;
  except
    result := pchar('ERROR' + #0);
  end;
end;

//------------------------------------------------------------------------------------------------------------
Function C_GetSaleTWC():pchar; stdcall; export;
var
    resposta:string;
    comando:string[7];
begin
  try
    comando:='(&A299)';
    resposta:=Get('LeAbastecimentoTWC',comando,3000);
    if(length(resposta)=123) then
    begin
      result := pchar(resposta + #0);
    end
    else
    begin
      result := pchar('');
    end;
  except
    result := pchar('');
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Function LeSTEncerrante(modo:string;bico:string):ShortString;stdcall; export;
//------------------------------------------------------------------------------------------------------------
Function C_SendReceiveText(comando:shortstring):shortstring;stdcall; export;
var
  a,timeout: integer;
  rta: shortstring;
begin
//messagedlg(comando,mterror,[mbok],0);
  //ShowMessage(comando);
  try
    for a := 1 to length(comando) do
      if comando[a] = ')' then break;
    comando := copy(comando,1,a);
    comando := '('+comando;
    timeout := 2000;
    rta := Get('C_SendReceiveText',comando,timeout);
    rta := inttostr(length(rta)) + rta;
    result := rta;
  except
    on E: Exception do result := pchar(e.Message);
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Function LeSTEncerrante(modo:string;bico:string):ShortString;stdcall; export;
Function CS_SendReceiveText(var pComando:pchar):integer;stdcall; export;
var
  a,timeout: integer;
  rta,comando: string;
begin
//messagedlg(pComando,mterror,[mbok],0);
  comando:='(' + pComando;
  try
    for a := 1 to length(comando) do if comando[a] = ')' then break;
    comando := copy(comando,1,a);
    comando := '(' + comando;
    timeout := 2000;
    rta := Get('C_SendReceiveText',comando,timeout);
    //  rta:=inttostr(length(rta)) + rta;
    pComando := pchar(rta);
    result := length(rta);
  except
    on E: Exception do result:=0;
  end;
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
// (TL1002732878A6)
// 1234567890123456
function C_ReadTotalsCash(bico:pchar):integer;stdcall; export;
var
  comando,resposta,encerrante: string;
begin
  if length(bico) = 2 then
  begin
    comando := AdicionaCheck('(&T' + bico + '$');
    resposta := Get('ConsultaEncerrante',comando,3000);
    //messagedlg(resposta,mterror,[mbok],0);

    if length(resposta) = 16 then
    begin
      if (copy(resposta,1,5) = '(T$' + bico) then
      begin
        encerrante := copy(resposta,6,8);
        try
          result := strtoint(encerrante);
        except
          result := -4;
        end;
      end
      else
      result := -3;
    end
    else
      result := -2;
  end
  else
    result := -1;
end;

//------------------------------------------------------------------------------------------------------------
// (TL1002732878A6)
// 1234567890123456
function C_ReadTotalsVolume(bico:pchar):integer;stdcall; export;
var
  comando,resposta,encerrante:string;
begin
  if length(bico) = 2 then
  begin
    comando := AdicionaCheck('(&T' + bico + 'L');
    resposta := Get('ConsultaEncerrante',comando,3000);
    if length(resposta) = 16 then
    begin
      if (copy(resposta,1,5) = '(TL' + bico) then
      begin
        encerrante := copy(resposta,6,8);
        try
          result := strtoint(encerrante);
        except
          result := -4;
        end;
      end
      else
        result := -3;
    end
    else
      result := -2;
  end
  else
    result := -1;
end;

//------------------------------------------------------------------------------------------------------------
// Comando : (&T04l4A)
// Resposta: (Tl04000004338319)
function C_ReadTotalsVolume2(bico:pchar):integer;stdcall; export;
var
  comando,resposta,encerrante: string;
begin
  if length(bico) = 2 then
  begin
    comando := AdicionaCheck('(&T' + bico + 'l');
    resposta := Get('ConsultaEncerrante',comando,3000);
    if length(resposta) = 18 then
    begin
      if (copy(resposta,1,5) = '(Tl' + bico) then
      begin
        encerrante := copy(resposta,6,10);
        try
          result := strtoint(encerrante);
        except
          result := -4;
        end;
      end
      else
        result := -3;
    end
    else
      result := -2;
  end
  else
    result := -1;
end;


//------------------------------------------------------------------------------------------------------------
// Comando : (&T04l4A)
// Resposta: (Tl04000004338319)
function C_ReadTotalsVolume3(bico:string):pchar;stdcall; export;
var
  comando,resposta,encerrante: string;
begin
  if length(bico) = 2 then
  begin
    comando := AdicionaCheck('(&T' + bico + 'l');
    resposta := Get('ConsultaEncerrante',comando,3000);
    if length(resposta) = 16 then
    begin
      if (copy(resposta,1,5) = '(TL' + bico) then
      begin
        encerrante := copy(resposta,6,10);
        try
          result := Pchar(encerrante + #0);
        except
          result := Pchar('-1' + #0);
        end;
      end
      else
        result := Pchar('-1' + #0);
    end
    else
      result := Pchar('-1' + #0);
  end
  else
    result := Pchar('-1' + #0);
end;

//------------------------------------------------------------------------------------------------------------
function C_ReadRegister(reg:pchar):pchar;stdcall;export;
var
  command,answer: string;
begin
  if((length(reg)) = 4) then
  begin
    command := AdicionaCheck('(&LR'+copy(reg,1,4));
    answer:=Get('ReadRegister',command,2000);
    if (length(answer)<=82) then
      result:=pchar(answer + #0)
    else
      result:=pchar('(0)' + #0);
  end
  else
    result:=pchar('(0)' + #0);
end;

//------------------------------------------------------------------------------------------------------------
function C_StopPump(bico:pchar):integer; stdcall; export;
var
  comando,resposta:string;
begin
  //  bico:=copy(bico,1,2);
  if((Length(bico))=2) then
  begin
    comando:=AdicionaCheck('(&M' + bico + 'S');
    resposta:=Get('AlteraModo',comando,1000);
    //result := pchar(resposta + #0);
    if resposta = '(M'+bico+')' then
    begin
      result := 1;
    end
    else
      result := 0;
  end
  else
    result := 0;
end;

Function C_SaveTagIdf(control1,control2:integer;tag:pchar):integer; stdcall; export;
var
  control:string[2];
  command:string;
  answer:string;
begin
  control:=IntToStr(control1) + IntToStr(control2);
  command:=AdicionaCheck('(?F'+control+'G'+tag+'0000000000000000');
  //ShowMessage(command+' - comando enviado na gravação de IDF');
  if length(command)=41 then
    begin
      answer:=Get('SaveTagFid',command,2000);
      //ShowMessage(answer+' - resposta recebida do comando de gravação de IDF');
      if (length(answer)=52) then
      begin
        if copy(answer,1,3)='(FG' then
          result:=strtoint(copy(answer,4,6))
        else
        result:=0;
      end
    end
  else
    result:=0;
end;

Function C_DeleteTagIdf(control,position,tag:pchar):integer; stdcall; export;
var command,answer:string;
begin
  if((length(position)) = 6) then
    begin
      command:=AdicionaCheck('(?F'+copy(control,1,2)+'A'+tag+'00'+copy(position,1,6)+'00000000');
      //ShowMessage(command+' - comando enviado na exclusão de IDF');
      if length(command)=41 then
        begin
          answer:=Get('deleteTagFid',command,2000);
                //ShowMessage(answer+' - resposta recebida do comando de exclusão de IDF');
          if length(answer)=52 then
              result:=strtoint(copy(answer,4,6))
          else
            result:=0;
        end
      else
      result:=0;
    end
  else
    result := 0;
end;

function C_ReadIdf():pChar; stdcall; export;
var
  command, answer: string;
begin
  command:=AdicionaCheck('(?A');
  answer:=Get('C_ReadIdf', command, 2000);
  if (length(answer)=37) then
      result:= PChar(answer + #0)
  else
    result:=PChar('(0)'+#0);
end;

Procedure C_IncrementIdf;stdcall; export;
var command:string;
begin
  command:=AdicionaCheck('(?I');
  Get('IncrementaFid', command, 1000);
end;

procedure C_ClearMemoryIdf; stdcall; export;
begin
  Get('clearTagFid','(?F00L0000000000000000000000010000000032)',5000);
end;

Function C_ReadRegisterIdf(nro:integer):pchar;stdcall; export;
var stnro:string[6];
    command:string;
    answer: string;
begin
  stnro := IntToStr(nro);
  while length(stnro)<6 do stnro:='0' + stnro;
  command:=AdicionaCheck('(?LF' + stnro);
  answer:=Get('LeFidRegistro',command,1000);
  if(Length(answer)=52) then
    result:=PChar(answer+#0)
  else
    result:=PChar('(0)'+#0);

end;

Function C_PushIdfBlackList(tag:pchar):integer;stdcall;export;
var command,answer:string;
begin
  try
    if(length(tag)=16) then
      begin
        command:=AdicionaCheck('(&M99b' + tag);
        answer:=Get('PushBlackList',command,2000);
        if(length(answer)>=4) then
            result:= 1
        else
            result:=0;
      end
    else
      begin
        result:=0;
      end;
  except
    result:= 0;
  end;
end;

Function C_RemoveIdfBlackList(tag:pchar):integer;stdcall;export;
var command,answer:string;
begin
  try
    if(length(tag)=16) then
    begin
      command := AdicionaCheck('(&M99l' + tag);
      answer:=Get('PopBlackList',command,2000);
      if(length(answer)>=4) then
        result:= 1
      else
        result:=0;
    end
    else
    begin
      result:=0;
    end;
  except
    result:= 0;
  end;
end;

//////////////////////////////////////////////////////////////////////////////////
//
//
//           BEGIN        VB_funtions
//
//
/////////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------------------------------------------
// Função LeAbastecimentoVB                                                                                  -
// Entrada: Nill                                                                                             -
// Saída: Variável formato Tabastecimento                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function VBLeAbastecimento:AbastVB; stdcall; export;
var
  ab: abast;
  abOut: abastVB;
begin
 ab := LeAbastecimento;
  abOut.value := ab.value;
  abOut.registro := ab.registro;
  abOut.integridade := ab.integridade;
  abOut.checksum := ab.checksum;
  abOut.encerrante := ab.encerrante;
  abOut.total_dinheiro := ab.total_dinheiro;
  abOut.total_litros := ab.total_litros;
  abOut.PU := ab.PU;
  abOut.tempo := ab.tempo;
  abOut.canal := ab.canal;
  abOut.data := ab.data;
  abOut.hora := ab.hora;
  abOut.st_full := ab.st_full;
  result := abOut;
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
// Função VBLeVisualizacao                                                                                   -
// Entrada: Nill                                                                                             -
// Saída: Variável formato Tabastecimento                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function VBLeVisualizacao:VBOnLine; stdcall; export;
var
  ol: OnLine;
  Visualizacao: VBOnLine;
  a: byte;
begin
  ol := LeVisualizacao;
  for a := 1 to 48 do
  begin
    Visualizacao. bico[a] := ol.bico[a];
    Visualizacao.volume[a] := ol.Litragem[a];
  end;
  result := Visualizacao;
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
// Função LeStatusVB                                                                                         -
// Entrada: Nill                                                                                             -
// Saída: Estrutura de status                                                                                -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeStatusVB():StStatus2; stdcall; export;
var stbomba:StStatus2;
    resposta:string[75];
    comando:string[4];
    a:integer;
begin
comando:='(&S)';
resposta:=Get('LeStatusVB','(&S)',1000);
For a:=1 to 48 do stbomba.Posicao[a]:='Falha';
if resposta[1]='(' then
    begin
    if resposta[2]='S' then
        begin
        For a:=3 to length(resposta)-1 do
            begin
            case resposta[a] of
                'L':stbomba.Posicao[a-2]:=('Livre');
                'P':stbomba.Posicao[a-2]:=('Pronta');
                'F':stbomba.Posicao[a-2]:=('Falha');
                'C':stbomba.Posicao[a-2]:=('Concluiu');
                'A':stbomba.Posicao[a-2]:=('Abastecendo');
                'B':stbomba.Posicao[a-2]:=('Bloqueada');
                'E':stbomba.Posicao[a-2]:=('SolicitaLib');
                end;
            end;
        end;
    end;
result:=stbomba;
end;
//------------------------------------------------------------------------------------------------------------


{
Function VB_SaveTagFid(controle:string;tag:string):integer; stdcall; export;
var comando:string;
    resposta:string;
begin
comando:=AdicionaCheck('(?F'+controle+'G'+'FFFFFFFFFFFFFFFF');
if length(comando)=41 then
  begin
  resposta:=Get('SaveTagFid',comando,2000);
  //(FGppppppMMMMMMttttttttttttttttAAAAaaaaBBBBbbbbCCKK)
  //1234567890123456789012345678901234567890123456789012
  //0        1         2         3         4         5
  if (length(resposta)=52) then
    begin
    if copy(resposta,1,3)='(FG' then
      result:=strtoint(copy(resposta,4,6))
    else
      result:=0;
    end
  end
else
  result:=0;
end;
   }
//------------------------------------------------------------------------------------------------------------
Function FechaSerialVB: boolean; stdcall; export;
begin
if FechaSerial=0 then result:=true else result:=false;
end;
//------------------------------------------------------------------------------------------------------------


//------------------------------------------------------------------------------------------------------------
// Função VBInicializaSerial                                                                                 -
// Entrada: String                                                                                           -
// Saída: True se acertou senão False                                                                        -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function VBInicializaSerial(porta:string):boolean;stdcall; export;
begin
result:=InicializaSerial(strtoint(porta));
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
// Função VBSetAutorizaAbast                                                                                 -
// Entrada: Nº do bico ou '00' para todas bombas                                                             -
// Saída: 1-OK 2-Cód. Bico 3-Modo 4-Timeout 5-Bomba                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
procedure VBSetAutorizaAbast(var bico:string); stdcall; export;
begin
  if AlteraModo(bico,'A')<>None then bico:='00';
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
// Função VBSetBloqueiaBico                                                                                  -
// Entrada: Nº do bico                                                                                       -
// Saída: '00' = erro                                                                                        -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
procedure VBSetBloqueiaBico(var bico:string); stdcall; export;
begin
  if AlteraModo(bico,'B')<>none then
   bico:='00';
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
// Função VBSetAutoLibera                                                                                    -
// Entrada: Nº do bico                                                                                       -
// Saída: '00' = erro                                                                                        -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
procedure VBSetAutoLibera(var bico:string); stdcall; export;
begin
  if AlteraModo(bico,'L')<>none then bico:='00';
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
// Função LeStringAbVb                                                                                       -
// Entrada: Nill                                                                                             -
// Saída: string                                                                                             -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function LeStringAbVB:ShortString; stdcall; export;
var rta:ShortString;
begin
  rta:=Get('LeStringAbVB','(&A)',1000);
  result:=rta;
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
function VB_SetPrice(bico,price:pchar):integer;stdcall; export;
var comando,resposta:string;
begin
  if (length(bico)=2) and (length(price)=4) then
    begin
      comando:=AdicionaCheck('(&U' + bico + '00' + price);
      resposta:=Get('AlteraPreco',comando,2000);
      if resposta='(U'+bico+')' then
        result:=1
      else
        result:=0;
    end
  else
    result:=0;
end;

//------------------------------------------------------------------------------------------------------------
// Função VB_SetPriceLevel                                                                                   -
// Entrada: bico (04), preco (7999), nivel (0, 1 ou 2)                                                       -
// Saída: inteiro informando se houve erro ou sucesso                                                        -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
function VB_SetPriceLevel(nozzle,price,level:pchar):integer;stdcall; export;
var comando,resposta:string;
begin
  if (length(nozzle)=2) and (length(price)=4) then
    begin
      comando := AdicionaCheck('(&U' + nozzle + level + '0' + price);
      resposta := Get('AlteraPreco',comando,2000);
      if resposta = '(U'+nozzle+')' then
        result:=1
      else
        result:=0;
    end
  else
    result:=0;
end;

//------------------------------------------------------------------------------------------------------------
// Função VB_ReadLevelPPLs                                                                                   -
// Entrada: bico (04), preco (7999), nivel (0, 1 ou 2)                                                       -
// Saída: inteiro informando se houve erro ou sucesso                                                        -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function VB_ReadLevelPPL(nozzle,levels:pchar):PPLNivel; stdcall; export;
var
  comando,resposta:string;
  precos: PPLNivel;
begin
  if levels = '1' then
  begin
    comando := AdicionaCheck('(&T' + nozzle + 'U');
    resposta := Get('LePPL',comando,2000);
    if length(resposta)=16 then
      precos.nivel0 := strtofloat(copy(resposta,10,4));
  end
  else if levels = '2' then
  begin
    comando:=AdicionaCheck('(&T' + nozzle + 'U');
    resposta:=Get('LePPL',comando,2000);
    if length(resposta)=16 then
      precos.nivel0 := strtofloat(copy(resposta,10,4));
      precos.nivel1 := strtofloat(copy(resposta,6,4));
  end
  else if levels = '3' then
  begin
    comando:=AdicionaCheck('(&T' + nozzle + 'u');
    resposta:=Get('LePPL',comando,2000);
    precos.nivel0 := strtofloat(copy(resposta,10,4));
    precos.nivel1 := strtofloat(copy(resposta, 6,4));
    precos.nivel2 := strtofloat(copy(resposta,14,4));
  end
  else
  begin
    precos.nivel0 := -1;
    precos.nivel1 := -1;
    precos.nivel2 := -1;
  end;
  result := precos;
end;

//------------------------------------------------------------------------------------------------------------
// Função VB_ReadPrice                                                                                       -
// Entrada: string contendo o bico (referencia)                                                              -
// Saída: string contendo o preço por litro                                                                  -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
function VB_ReadPrice(var nozzle:string):integer;stdcall; export;
var command, answer:string;
begin
  command := AdicionaCheck('(&T' + nozzle + 'U');
  //ShowMessage(command + ' - comando enviado');

  answer := Get('VB_ReadPrice', command, 2000);
  //ShowMessage(answer + ' - resposta recebida');

  if length(answer) = 16 then
  begin
    nozzle := copy(answer,10,4);
    Result := 1;
  end
  else if answer = 'DESCONECTADO' then
  begin
    nozzle := '';
    Result := 0;
  end
  else
  begin
    nozzle := '';
    Result := 2;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função VBLePPL                                                                                            -
// Entrada: string contendo o bico (referencia)                                                              -
// Saída: string contendo encerrante (referencia)                                                            -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure VBLePPL(var inf:shortstring);stdcall; export;
var resposta,comando:string;
begin
  comando := AdicionaCheck('(&T' + inf + 'U');
  resposta := Get('VBLePPL',comando,2000);
  if length(resposta) = 16 then
    inf := copy(resposta,10,4)
  else if resposta='DESCONECTADO' then
    inf := '0'
  else
    inf := '-1';
end;

//------------------------------------------------------------------------------------------------------------
// Função VBSetPPL                                                                                           -
// Entrada: string contendo o bico e o valor BBVVVV (referencia)                                             -
// Saída: string contendo encerrante (referencia)                                                            -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure VBSetPPL(var inf:string);stdcall; export;
var resposta,comando:string;
begin
  comando:= AdicionaCheck('(&U' + copy(inf,1,2) + '00' + copy(inf,3,4));
  resposta:=Get('VBSetPPL',comando,2000);
  if resposta='DESCONECTADO' then
    inf:='0'
  else
    inf:=resposta;
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
// Bloco de funções Visual Basic                                                                             -
//------------------------------------------------------------------------------------------------------------
Function VB_OpenSerial(np:integer):integer;stdcall; export;
begin
if InicializaSerial(np) then result:=1 else result:=0;
end;


Function VB_CloseSerial:integer;stdcall; export;
begin
result:=FechaSerial;
end;

//------------------------------------------------------------------------------------------------------------
Function VB_SendText(st:shortstring):integer;stdcall; export;
var a:byte;

begin
result:=0;
st:=trim(st);
if length(st)>=3 then
  begin
  if st[1]<>'(' then st:='(' + st;
  for a:=2 to length(st) do
    begin
    if st[a]=')' then
      begin
      st:=copy(st,1,a);
      if SendText('VB_SendText',st) then result:=1;
//      messagedlg('Enviou: ' + st,mtinformation,[mbok],0);
      end;
    end;
  end;
end;

//------------------------------------------------------------------------------------------------------------
Function VB_ReceiveText(var st:pchar):integer;stdcall; export;
var rec:string;
begin
//messagedlg('Recebido :' + st,mtinformation,[mbok],0);
rec:=Get('VB_ReceiveText','',2000);
result:=length(rec);
st:=pchar(rec);
//messagedlg('Enviando-> :' + st,mtinformation,[mbok],0);

end;


//------------------------------------------------------------------------------------------------------------
Function VB_STReceiveText():string;stdcall; export;
var rec:string;
begin
//messagedlg('Recebido :' + st,mtinformation,[mbok],0);
rec:=Get('VB_ReceiveText','',2000);
//messagedlg('Enviando-> :' + rec,mtinformation,[mbok],0);
result:=rec;
//st:=rec;
//messagedlg('Enviando-> :' + st,mtinformation,[mbok],0);

end;
//------------------------------------------------------------------------------------------------------------
Function VB_TesteREF(var st:string):string; stdcall;export;
//var rec:string;
begin
  //messagedlg('Recebido :' + st,mtinformation,[mbok],0);
  result := st;
end;

Function VB_TesteVAL(st:string):string;stdcall;export;
//var rec:string;
begin
  //messagedlg('Recebido :' + st,mtinformation,[mbok],0);
  result := st;
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
function VB_SendReceiveText(var st:string;timeout:integer):string;stdcall;export;
var
  rec,comando:string;
//  a:integer;
begin
  try
    begin
          (*ShowMessage(st);
          for a := 1 to length(st) do
          begin
            ShowMessage(st[a]);
          end;*)

      //for a:=1 to length(st) do
      //  if st[a]=')'
      //  then
      //    break;
          
      comando:=copy(st,0,Length(st));

      if timeout < 1000 then timeout := 1000;
      rec := Get('VB_SendReceiveText',comando,timeout);
      //ShowMessage(rec);
      //st := PAnsiChar(AnsiString(rec));
      //result := length(rec);
      result := rec;
    end
  except
    on E: Exception do
      begin
        result := '0';
      end;
  end;
end;

//------------------------------------------------------------------------------------------------------------
Function VB_ReadSale(var st:string):integer;stdcall; export;
var rec:string;
begin
  rec:=Get('VB_ReadAbastecimento','(&A)',1000);
  //messagedlg(rec,mtinformation,[mbok],0);
  if (length(rec)=52) or (length(rec)=34) then
     begin
        st:=rec;
        result:=1;
     end
  else if rec='(0)' then
    begin
      st:=rec;
      result:=2;
    end
  else
    begin
      st:='';
      result:=0;
    end;
end;

Function VB_ReadSaleFmGreaterFour(var str: WideString):Integer;stdcall; export;
var rec:string;
begin
  rec := Get('VB_ReadAbastecimento','(&A)',1000);
  //messagedlg(rec,mtinformation,[mbok],0);
  if (length(rec)=52) or (length(rec)=34) then
    begin
      str := rec;
      result := 1;
    end
  else
    begin
      result := 0;
    end;
end;

//(a2G0000511800040000324212343E00070405114707110008770000555351000055502612345600987654000000000000000000000000000000000081)
//1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
//         1         2         3         4         5         6         7         8         9         0         1         2  3
//------------------------------------------------------------------------------------------------------------
Function VB_ReadSalePAF(var st:string):integer;stdcall; export;
var rec:string;
begin
  rec := Get('VB_ReadAbastecimento','(&A299)',1000);
  //messagedlg(rec,mtinformation,[mbok],0);
  if (length(rec)=123)  then
    begin
      st := rec;
      result := 1;
    end
  else if rec = '(0)' then
    begin
      st := rec;
      result := 2;
    end
  else
    begin
      st := '';
      result := 0;
    end;
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
Function VB_ReadSale2(var st:pointer):integer;stdcall; export;
var comando:string;
begin
  comando := PcharToStr(st);
  st := StrToPchar(st,'123');
end;

//------------------------------------------------------------------------------------------------------------
Function VB_ReadSale3:widestring;stdcall; export;
var rec:string;
begin
  rec := Get('VB_SendReceiveText','(&A)',1000);
  //messagedlg(rec,mtinformation,[mbok],0);
  result := rec;
end;

//------------------------------------------------------------------------------------------------------------
//(A01534407793019693A013610071819071732000091172000B3CF89D2D5E6735B173200CD)
//(A00015000135211113E001B042814510200740665083057000000000000000000007400FA)
//123456789012345678901234567890123456789012345678901234567890123456789012345
//0        1         2         3         4         5         6         7
Function VB_ReadSaleId(var st:string):integer;stdcall; export;
var rec:string;
begin
  rec := Get('VB_ReadAbastecimento','(&A67)',1000);
  //messagedlg('Teste:' + rec + ':' + inttostr(length(rec)),mterror,[mbok],0);
  if (length(rec)=75) then
    begin
      st := rec;
      result := 1;
    end
  else if rec = '(0)' then
    begin
      st := rec;
      result := 2;
    end
  else
    begin
      st := '';
      result := 0;
    end;
end;

//------------------------------------------------------------------------------------------------------------
//(@00078800070211233A00070428152102000100000110890000000000000000000000000000000000000F)

//(@00015000135211113E001B0428145102007406650830570000000000000000000000000000000000002E)
//123456789012345678901234567890123456789012345678901234567890123456789012345678901234567
//0        1         2         3         4         5         6         7         8
Function VB_ReadSale2Id(var st:string):integer;stdcall; export;
var rec:string;
begin
  rec := Get('VB_ReadAbastecimento','(&@66)',5000);
  //messagedlg(rec,mterror,[mbok],0);
  if (length(rec)=87) then
    begin
      st := rec;
      result := 1;
    end
  else if rec = '(0)' then
    begin
      st := rec;
      result := 2;
    end
  else
    begin
      st := '';
      result := 0;
    end;
end;

//------------------------------------------------------------------------------------------------------------
function VB_NextSale:integer;stdcall; export;
begin
result := VB_SendText('(&I)');
end;



//------------------------------------------------------------------------------------------------------------
// bicoprice = BB00PPPP
function VB_SetPrice2(bicoprice:string):integer;stdcall; export;
var comando,resposta:string;
begin
  bicoprice :=copy(bicoprice,1,8);
  if ((length(bicoprice))=8) then
    begin
      comando:=AdicionaCheck('(&U' + bicoprice);
      resposta:=Get('AlteraPreco',comando,2000);
      if resposta='(U'+copy(bicoprice,1,2)+')' then
        result:=1
      else
        result:=0;
    end
  else
    result:=0;
end;

//------------------------------------------------------------------------------------------------------------
function VB_PresetPump(bico,cash:string):integer;stdcall; export;
var comando,resposta:string;
begin
  bico:=copy(bico,1,2);
  cash:=copy(cash,1,6);
  if ((length(bico))=2) and (length(cash)=6) then
    begin
      comando:=AdicionaCheck('(&P' + bico + cash);
      resposta:=Get('Preset',comando,1000);
      if resposta='(P'+bico+')' then
        result:=1
      else
        result:=0;
    end
  else
    result:=0;
end;

//------------------------------------------------------------------------------------------------------------
//(SFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6V2.3M7.0G8B)                                                        -
//123456789012345678901234567890123456789012345678901                                                        -
//------------------------------------------------------------------------------------------------------------
function VB_ReadState(var st:string):integer;stdcall; export;
var rec:string;
begin
  rec:=Get('VB_ReadState','(&S)',1000);
  if length(rec)=51 then
    begin
      st:=rec;
      result:=1;
    end
  else
    begin
      st:='';
      result:=0;
    end;
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------------------------------------
Function VB_OpenSocket(ip:string):integer;stdcall; export;
var pip:pchar;
begin
try
  pip:=pchar(ip);
  //messagedlg('OPENSOCKET RECEBIDO :: ' + ip,mtinformation,[mbok],0);
  if InicializaSocket(pip) then result:=1 else result:=0;
except
  result:=0;
end;
end;

//------------------------------------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------------------------------------
Function VB_CloseSocket:integer;stdcall; export;
begin
if FechaSocket then result:=1 else result:=0;
end;

//------------------------------------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------------------------------------
Function VB_SetState(bico,estado:string):integer;stdcall; export;
var comando,resposta:string;
begin
  if (length(bico)=2) and ((estado='A') or (estado='B') or (estado='L')) then
    begin
      comando:=AdicionaCheck('(&M' + bico + estado);
      resposta:=Get('AlteraModo',comando,1000);
      if resposta='(M'+bico+')' then
        result:=1
      else
        result:=0;
    end
  else
    result:=0;
end;

//------------------------------------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------------------------------------
Function VB_BlockPump(bico:string):integer;stdcall; export;
var comando,resposta:string;
begin
  bico:=copy(bico,1,2);
  if length(bico)=2 then
    begin
      comando:=AdicionaCheck('(&M' + bico + 'B');
      resposta:=Get('AlteraModo',comando,1000);
      if resposta='(M'+bico+')' then
        result:=1
      else
        result:=0;
    end
  else
    result:=0;
end;

//------------------------------------------------------------------------------------------------------------
Function Lock(bico:pchar):integer;stdcall; export;
begin
result:=VB_BlockPump(bico);
end;

//------------------------------------------------------------------------------------------------------------
Function VB_FreePump(bico:string):integer;stdcall; export;
var comando,resposta:string;
begin
  bico:=copy(bico,1,2);
  if length(bico)=2 then
    begin
      comando:=AdicionaCheck('(&M' + bico + 'L');
      resposta:=Get('AlteraModo',comando,1000);
      if resposta='(M'+bico+')' then
        result:=1
      else
        result:=0;
    end
  else
    result:=0;
end;

//------------------------------------------------------------------------------------------------------------
Function VB_StopPump(bico:string):integer;stdcall; export;
var comando,resposta:string;
begin
  bico:=copy(bico,1,2);
  if length(bico)=2 then
    begin
      comando:=AdicionaCheck('(&M' + bico + 'S');
      resposta:=Get('AlteraModo',comando,1000);
      if resposta='(M'+bico+')' then
        result:=1
      else
        result:=0;
    end
  else
    result:=0;
end;

//------------------------------------------------------------------------------------------------------------
Function VB_SaveTagFid(CodId:integer ;tag:string):integer;stdcall;export;
var
    comando:string;
    resposta:string;
begin
  comando:=AdicionaCheck('(?F'+ string(CodId) + 'G' + tag + 'FFFFFFFFFFFFFFFF');
  if length(comando)=41 then
    begin
      resposta:=Get('SaveTagFid',comando,2000);
      if (length(resposta)=52) then
        begin
          if copy(resposta,1,3)='(FG' then
            result:=strtoint(copy(resposta,4,6))
          else
            result:=0;
        end
    end
  else
    result:=0;
end;

Function Unlock(bico:pchar):integer;stdcall; export;
begin
  result:=VB_FreePump(bico);
end;

//------------------------------------------------------------------------------------------------------------
function GetState(bico:pchar):integer;
var intBico:byte;
  status:string;
begin
  if VB_ReadState(status)=1 then
    begin
      intBico:=strtoint('$'+bico);
      while intBico>64 do intBico:=intBico-64;
      intBico:=intBico-3;
      if status[intBico]='F' then result:=1 else
      if status[intBico]='A' then result:=2 else
      if status[intBico]='L' then result:=3 else
      if status[intBico]='B' then result:=4 else
      if status[intBico]='E' then result:=5 else
      if status[intBico]='C' then result:=6 else
      if status[intBico]='P' then result:=7 else
      result:=99;
    end
  else
    result:=0;
end;


//------------------------------------------------------------------------------------------------------------
Function VB_AutPump(bico:string):integer;stdcall; export;
var comando,resposta:string;
begin
  bico:=copy(bico,1,2);
  if length(bico)=2 then
    begin
      comando:=AdicionaCheck('(&M' + bico + 'A');
      resposta:=Get('AlteraModo',comando,1000);
      if resposta='(M'+bico+')' then
        result:=1
      else
        result:=0;
    end
  else
    result:=0;
end;

Function Authorize(bico:Pchar):integer;stdcall; export;
begin
  result:=VB_AutPump(bico);
end;

//------------------------------------------------------------------------------------------------------------
// modo: 1=Livre / 2=Bloqueia / 3=autoriza / 4=para
function SetMode(bico,modo:byte):boolean;stdcall; export;
var bicoHex:String[2];
begin
  result:=false;
  bicoHex:=inttohex(bico,2);
  if modo=1 then
    result:=SetAutoLibera(bicoHex)
  else if modo=2 then
    result:=SetBloqueiaBico(bicoHex)
  else if modo=3 then
    result:=SetAutorizaAbast(bicoHex)
  else if modo=4 then
    result:=SetParaBomba(bicoHex);
end;

//------------------------------------------------------------------------------------------------------------
// (TL1002732878A6)
// 1234567890123456
function VB_ReadTotalsCash(bico:pchar):integer;stdcall; export;
var comando,resposta,encerrante:string;
begin
  if length(bico)=2 then
    begin
      comando:=AdicionaCheck('(&T' + bico + '$');
      resposta:=Get('ConsultaEncerrante',comando,3000);
      if length(resposta)=16 then
        begin
          if (copy(resposta,1,5)='(T$'+bico) then
            begin
              encerrante:=copy(resposta,6,8);
              try
                result:=strtoint(encerrante);
              except
                result:=-1;
              end;
            end
          else
            result:=-1;
        end
      else
        result:=-1;
    end
  else
    result:=-1;
end;

//------------------------------------------------------------------------------------------------------------
function ReadTotalsCash(bico:pchar):integer;stdcall; export;
begin
  result := ReadTotalsCash(bico);
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
// (TL1002732878A6)
// 1234567890123456
function VB_ReadTotalsVolume(bico:string):integer;stdcall; export;
var
  comando,resposta,encerrante:string;
begin
  bico:=copy(bico,1,2);
  if length(bico)=2 then
    begin
      comando:=AdicionaCheck('(&T' + bico + 'L');
      resposta:=Get('ConsultaEncerrante',comando,3000);
      if length(resposta)=16 then
        begin
          if (copy(resposta,1,5)='(TL'+bico) then
            begin
              encerrante:=copy(resposta,6,8);
              try
                result:=strtoint(encerrante);
              except
                result:=-1;
              end;
            end
          else
            result:=-1;
        end
      else
        result:=-1;
    end
  else
    result:=-1;
end;

//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
// (T04l1234567890A6)
// 123456789012345678
function VB_ReadTotalsVolumeExtended(bico:string):integer;stdcall; export;
var
  comando,resposta,encerrante:string;
begin
  bico:=copy(bico,1,2);
  if length(bico)=2 then
    begin
      comando:=AdicionaCheck('(&T' + bico + 'l');
      resposta:=Get('ConsultaEncerrante',comando,3000);
      if length(resposta)=18 then
        begin
          if (copy(resposta,1,5)='(Tl'+bico) then
            begin
              encerrante:=copy(resposta,6,10);
              try
                result:=strtoint(encerrante);
              except
                result:=-1;
              end;
            end
          else
            result:=-1;
        end
      else
        result:=-1;
    end
  else
    result:=-1;
end;

//------------------------------------------------------------------------------------------------------------
function ReadTotalsVolume(bico:string):integer;stdcall; export;
begin
  result:=VB_ReadTotalsVolume(bico);
end;
//------------------------------------------------------------------------------------------------------------


//////////////////////////////////////////////////////////////////////////////////
//
//
//           END        VB_funtions
//
//
/////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//
//
//           BEGIN        Cob_funtions
//
//
/////////////////////////////////////////////////////////////////////////////////
      //------------------------------------------------------------------------------------------------------------
// Função CobAlteraPreco                                                                                     -
// Entrada: Nº do bico / novo preço	('BB9999')                                                               -
// Saída: Estrutura Error                                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function CobAlteraPreco(a:ShortString):error; stdcall; export;
var comando,resposta:string;
    Bico:string[2];
    Preco:string[4];
begin
  Bico:=copy(a,1,2);
  Preco:=copy(a,3,4);
  //messagedlg('Param de Entrada : ' + a,mtinformation,[mbok],0);
  //messagedlg('Bico : ' + bico,mtinformation,[mbok],0);
  //messagedlg('Preco: ' + preco,mtinformation,[mbok],0);
  comando:=AdicionaCheck('(&U' + bico + '00' + Preco);
  //messagedlg('Comando : ' + comando,mtinformation,[mbok],0);
  resposta:=Get('CobAlteraPreco',comando,2000);
  result:=InformaErro(resposta,bico);
end;

//------------------------------------------------------------------------------------------------------------
// Procedimento CobLeVis                                                                                     -
// Entrada: Variavel visualizacao byRef                                                                      -
// Saída: Variavel visualizacao                                                                              -
//------------------------------------------------------------------------------------------------------------
Procedure CobLeVis(var st:visualizacao);stdcall;export;
var resposta,comando:string;
begin
  comando := '(&V)';
  resposta := Get('CobLeVis',comando,1000);
  st.stfull := resposta;
end;


//------------------------------------------------------------------------------------------------------------
// Função CobLeSTEncerrante                                                                                  -
// Entrada: tipo do pedido,nro. do bico   ('$01')                                                            -
// Saída: String com o valor              ('01 / 000000,00')                                                 -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure CobLeEnc(var a:enc);stdcall; export;
var comando,resposta,rt:string;
begin
  //if a.tipo<>'$' then a.tipo:='L';
  comando:=AdicionaCheck('(&T' + a.bico + a.tipo);
  resposta:=Get('CobLeEnc',comando,3000);
  if length(resposta)=16 then rt:=copy(resposta,6,8);
  a.valor:=rt;
end;

// (TMBBeeeeeeeeeeKK)
// 123456789012345678
//------------------------------------------------------------------------------------------------------------
Procedure CobLeEnc2(var a:enc2);stdcall; export;
var comando,resposta,rt:string;
begin
  a.tipo:='l';
  comando:=AdicionaCheck('(&T' + a.bico + a.tipo);
  resposta:=Get('CobLeEnc2',comando,3000);
  if length(resposta)=18 then rt:=copy(resposta,6,10);
  a.valor:=rt;
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
// Função CobLePPL                                                                                           -
// Entrada: Nº do bico ('BB')                                                                                -
// Saída: preço unitário:string ('0000')                                                                     -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function CobLePPL(var a:ShortString):error; stdcall; export;
var resposta:string[16];
    comando:string[10];
    res:error;
begin
  comando:=AdicionaCheck('(&T' + a + 'U');
  resposta:=Get('CobLePPL',comando,2000);
  a:='0000';
  if length(resposta)=16 then
    begin
      a:=copy(resposta,10,4);
      res:=None;
    end
  else
  res:=ErroResposta;
  result:=res;
end;
//------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------
// Função CobPreset                                                                                          -
// Entrada: Nº do bico, Valor do preset   ('BB999999')                                                       -
// Saída: Estrutura Error                                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function CobPreset(a:ShortString):Error; stdcall; export;
var comando,resposta:string;
    Bico:string[2];
    valor:string[6];
begin
  //messagedlg('Param de Entrada : ' + a,mtinformation,[mbok],0);
  Bico:=copy(a,1,2);
  Valor:=copy(a,3,6);
  comando:=AdicionaCheck('(&P' + bico + valor);
  resposta:=Get('CobPreset',comando,1000);
  result:=InformaErro(resposta,bico);
end;


//------------------------------------------------------------------------------------------------------------
// Função CobSetClock                                                                                        -
// Entrada: ddhhmm  ->  dd=dia hh=Hora mm=Minuto ou auto=automatico                                          -
// Saída: True se acertou senão False                                                                        -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function CobSetClock(par:ShortString):boolean; stdcall; export;
var resposta,comando:string;
    cont,dia,hora,minuto:byte;
begin
  if (uppercase(par)='AUTO') then
      comando:='(&H' + formatdatetime('ddhhnn',now) + ')'
  else
    begin
      dia:=strtoint(copy(par,1,2));
      hora:=strtoint(copy(par,3,2));
      minuto:=strtoint(copy(par,5,2));
      if parseDate(hora,minuto,dia,monthof(now),yearof(now)) then
        begin
          comando:='(&H' + par + ')';
          cont:=0;resposta:='';
          while (resposta<>'(&H)') and (cont<3) do
            begin
              resposta:=Get('CobSetClock',comando,500);
              inc(cont);
            end;
          if resposta='(&H)' then result:=true else result:=false;
        end;
    end;
end;

//------------------------------------------------------------------------------------------------------------
// Função CobReadIdfOfMemory                                                                                 -
// Entrada: StIndice - posição de memória a ser lida                                                         -
// Saída: String da resposta inteira                                                                         -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
function CobReadIdfOfMemory(idx: ShortString):ShortString; stdcall; export;
var
  command:string;
  answer:string;
  stIndice:string[6];
begin
  stIndice := idx;
  while length(stIndice) < 6 do stIndice := '0' + stIndice;
  command := adicionacheck('(?LF' + stIndice);

  answer := Get('readTagFid',command,2000);

  if length(answer) = 52 then
  begin
    result := answer;
  end
  else
  begin
     result := '(0)';
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função CobClearMemoryIdf                                                                                  -
// Entrada: nenhuma                                                                                          -
// Saída: nenhuma                                                                                            -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
procedure CobClearMemoryIdf; stdcall; export;
begin
  Get('clearTagFid','(?F00L0000000000000000000000010000000032)',5000);
end;

//------------------------------------------------------------------------------------------------------------
// Função CobSaveTagFid                                                                                      -
// Entrada: controle e tag do identificador                                                                  -
// Saída:                                                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function CobSaveTagFid(control,tag:ShortString):ShortString;stdcall;export;
var
    command:string;
    answer:string;
    stControl: string[2];
    stTag: string[16];
begin
    stControl := control;
    stTag := tag;

    command := AdicionaCheck('(?F' + stControl + 'G' + stTag + 'FFFFFFFFFFFFFFFF');
    answer := Get('SaveTagFid',command,2000);

    if (length(answer) = 52) then
    begin
      result := copy(answer,4,6);
    end
    else
    begin
      result := '(0)';
    end;
end;

//------------------------------------------------------------------------------------------------------------
// Função CobDeleteTagIdf                                                                                    -
// Entrada: controle, posição do idf na memória e tag do identificador                                       -
// Saída: posição do IDF na memória                                                                          -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function CobDeleteTagIdf(control,position,tag:ShortString):ShortString; stdcall; export;
var
  command,answer:string;
  stPosition: string[6];
  stControl:string[2];
  stTag:string[16];
begin
    stPosition := position;
    stControl := control;
    stTag := tag;
    while length(stPosition) < 6 do stPosition := '0' + stPosition;

    command := AdicionaCheck('(?F' + copy(stControl,1,2) + 'A' + stTag + '00' + copy(stPosition,1,6) + '00000000');
    answer := Get('deleteTagFid',command,2000);

    if length(answer) = 52 then
    begin
      result := copy(answer,4,6);
    end
    else
    begin
      Result := '(0)';
    end;

end;

//------------------------------------------------------------------------------------------------------------
// Função CobPushIdfBlackList                                                                                -
// Entrada: tag do idf para ser colocada da lista negra                                                      -
// Saída: 1 se retorno ok, 0 se retorno de erro                                                              -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function CobPushIdfBlackList(tag:ShortString):integer;stdcall;export;
var command,answer:string;
begin
  try
    if(length(tag) = 16) then
      begin
        command := AdicionaCheck('(&M99b' + tag);
        answer := Get('PushBlackList',command,2000);
        if(answer = '(M99)') then
            result:= 1
        else
            result:=0;
      end
    else
      begin
        result:=0;
      end;
  except
    result:= 0;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função CobPopIdfBlackList                                                                                 -
// Entrada: tag do idf para ser retirada da lista negra                                                      -
// Saída: 1 se retorno ok, 0 se retorno de erro                                                              -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function CobPopIdfBlackList(tag:ShortString):integer;stdcall;export;
var command,answer:string;
begin
  try
    if(length(tag) = 16) then
      begin
        command := AdicionaCheck('(&M99l' + tag);
        answer := Get('PopBlackList',command,2000);
        if(answer = '(M99)') then
            result:= 1
        else
            result:=0;
      end
    else
      begin
        result:=0;
      end;
  except
    result:= 0;
  end;
end;

//------------------------------------------------------------------------------------------------------------
// Função CobClearIdfBlackList                                                                               -
// Entrada: nenhuma                                                                                          -
// Saída: 1 se retorno ok, 0 se retorno de erro                                                              -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Function CobClearIdfBlackList():integer;stdcall;export;
var command,answer:string;
begin
  try
    command := AdicionaCheck('(&M99c');
    answer := Get('ClearBlackList',command,2000);
    if(answer = '(M99)') then
      result := 1
    else
      result := 0;
  except
    result:= 0;
  end;
end;
//------------------------------------------------------------------------------------------------------------
// Função CobLeStructIDSt                                                                                    -
// Entrada: variável estrutura (referencia)                                                                  -
// Saída: variável estrutura (referencia)                                                                    -
// Sub-Functions: None                                                                                       -
// (A00000000027018993A000908161148040074000091978900000000000000000000740004)                               -
// (A00200000118416893E006108161605113248008982550600B3CF6CC7B739C451324800C5)                               -
// (A00423501694924993E00060701010101000500019330330000000000000000000028)                                   -
// 123456789012345678901234567890123456789012345678901234567890123456789012345                               -
//          1         2         3         4         5         6         7                                    -
//------------------------------------------------------------------------------------------------------------
Procedure CobLeStructIDSt(var ab:abast3);stdcall; export;
var resposta:string[75];
begin
  resposta:=Get('CobLeStructSt','(&A67)',2000);
  if (length(resposta)=75) then
    begin
      if resposta[2]='A' then ab.value:='1' else ab.value:='0';
      ab.total_dinheiro:=copy(resposta,3,6);
      ab.total_litros:=copy(resposta,9,6);
      ab.PU:=copy(resposta,15,4);
      ab.tempo:=formatatempo(copy(resposta,21,4));
      ab.canal:=copy(resposta,25,2);
      ab.data:=copy(resposta,27,2) + '/' + copy(resposta,33,2) + '/' + formatdatetime('yyyy',now);
      ab.hora:=copy(resposta,29,2) + ':' + copy(resposta,31,2);
      ab.st_full:=resposta;
      ab.registro:=copy(resposta,35,4);
      ab.encerrante:=copy(resposta,39,10);
      ab.integridade:=resposta[49];
      ab.id:=copy(resposta,51,16);
      FidIncrementaAbast;
      if ComparaCheck(resposta) then ab.checksum:='1' else ab.checksum:='0';
    end
  else if resposta='(0)' then
    begin
      ab.value:='0';
      ab.total_dinheiro:='0';
      ab.total_litros:='0';
      ab.PU:='0';
      ab.tempo:='00:00:00';
      ab.canal:='00';
      ab.data:='00/00/0000';
      ab.hora:='00:00';
      ab.st_full:='(0000000000000000000000000000000000)';
      ab.registro:='0';
      ab.encerrante:='0';
      ab.integridade:='0';
      ab.checksum:='0';
    end
  else
    begin
      ab.value:='0';
      ab.total_dinheiro:='0';
      ab.total_litros:='0';
      ab.PU:='0';
      ab.tempo:='00:00:00';
      ab.canal:='99';
      ab.data:='00/00/0000';
      ab.hora:='00:00';
      ab.st_full:=resposta;
      ab.registro:='0';
      ab.encerrante:='0';
      ab.integridade:='0';
      ab.checksum:='0';
    end;
  resposta:='';
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStructSt                                                                                         -
// Entrada: variável estrutura (referencia)                                                                  -
// Saída: variável estrutura (referencia)                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure CobLeStructSt(var ab:abast2);stdcall; export;
var resposta:string;
begin
resposta:=Get('CobLeStructSt','(&A)',1000);
if (length(resposta)=34) or (length(resposta)=52) then
    begin
      ab.value:='1';
      ab.total_dinheiro:=copy(resposta,2,6);
      ab.total_litros:=copy(resposta,8,6);
      ab.PU:=copy(resposta,14,4);
      ab.tempo:=formatatempo(copy(resposta,20,4));
      ab.canal:=copy(resposta,24,2);
      if length(resposta)=34 then ab.data:=copy(resposta,26,2) + '/' + formatdatetime('mm/yyyy',now) else
      if length(resposta)=52 then ab.data:=copy(resposta,26,2) + '/' + copy(resposta,32,2) + '/' + formatdatetime('yyyy',now);
      ab.hora:=copy(resposta,28,2) + ':' + copy(resposta,30,2);
      ab.st_full:=resposta;
      if length(resposta)=52 then ab.registro:=copy(resposta,34,4) else
      if length(resposta)=34 then ab.registro:='0000';
      if length(resposta)=52 then ab.encerrante:=copy(resposta,38,10) else
      if length(resposta)=34 then ab.encerrante:='0000000000';
      if length(resposta)=52 then ab.integridade:=resposta[49] else
      if length(resposta)=34 then ab.integridade:='1';
      if ComparaCheck(resposta)=true then ab.checksum:='1' else ab.checksum:='0';
    Incrementa;
    end
else if resposta='(0)' then
    begin
      ab.value:='0';
      ab.total_dinheiro:='0';
      ab.total_litros:='0';
      ab.PU:='0';
      ab.tempo:='00:00:00';
      ab.canal:='00';
      ab.data:='00/00/0000';
      ab.hora:='00:00';
      ab.st_full:='(0000000000000000000000000000000000)';
      ab.registro:='0';
      ab.encerrante:='0';
      ab.integridade:='0';
      ab.checksum:='0';
    end
else
    begin
      ab.value:='0';
      ab.total_dinheiro:='0';
      ab.total_litros:='0';
      ab.PU:='0';
      ab.tempo:='00:00:00';
      ab.canal:='99';
      ab.data:='00/00/0000';
      ab.hora:='00:00';
      ab.st_full:=resposta;
      ab.registro:='0';
      ab.encerrante:='0';
      ab.integridade:='0';
      ab.checksum:='0';
    end;
resposta:='';
end;

//------------------------------------------------------------------------------------------------------------
// Função LeStructSt                                                                                         -
// Entrada: variável estrutura (referencia)                                                                  -
// Saída: variável estrutura (referencia)                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
// (a2$SSSSSSSSTTTTTTLLLLLLPPPPVVCCCCBBDDHHMMNNAARRRRRRffffffffffiiiiiiiiiibbccttvvvvvvvvIIIIIIIIIIIIIIIIJJJJJJJJJJJJJJJJnnKK)
// (a2G0000511800040000324212343E00070405114707110008770000555351000055502612345600987654000000000000000000000000000000000081)
// 123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
// 0        1         2         3         4         5         6         7         8         9        10        11        12
Procedure CobLeStructStId(var ab:CobAbastId);stdcall; export;
var resposta:string;
begin
  resposta:=Get('CobLeStructStID','(&A299)',1000);
  if (length(resposta)=123) then
      begin
        ab.value := '1';
        ab.habilitacao := copy(resposta,4,1);
        ab.serial_console := Copy(resposta,5,8);
        ab.total_dinheiro := copy(resposta,13,6);
        ab.total_litros := copy(resposta,19,6);
        ab.PU := copy(resposta,25,4);
        ab.cod_virgula := Copy(resposta,29,2);
        ab.tempo := formatatempo(copy(resposta,31,4));
        ab.canal := copy(resposta,35,2);
        ab.data := copy(resposta,37,2) + '/' + copy(resposta,43,2) + '/20' + copy(resposta,45,2);
        ab.hora := copy(resposta,39,2) + ':' + copy(resposta,41,2);
        ab.registro := copy(resposta,49,4);
        ab.encerrante := copy(resposta,53,10);
        ab.encerrante_inicial := Copy(resposta,63,10);
        ab.bico_pista := Copy(resposta,73,2);
        ab.tipo_combustivel := copy(resposta,75,2);
        ab.numero_tanque := Copy(resposta,77,2);
        ab.volume_tanque := Copy(resposta,79,8);
        ab.Tag := copy(resposta,87,16);
        ab.Tag2 := copy(resposta,103,16);
        ab.integridade := resposta[120];
        ab.st_full := resposta;
        if ComparaCheck(resposta)=true then ab.checksum:='1' else ab.checksum:='0';
        Incrementa;
      end
  else if resposta='(0)' then
      begin
        ab.value:='0';
        ab.habilitacao := '0';
        ab.serial_console := '0';
        ab.total_dinheiro := '0';
        ab.total_litros := '0';
        ab.PU := '0';
        ab.cod_virgula := '0';
        ab.tempo := '00:00:00';
        ab.canal := '00';
        ab.data := '00/00/0000';
        ab.hora := '00:00';
        ab.registro := '0';
        ab.encerrante := '0';
        ab.encerrante_inicial := '0';
        ab.bico_pista := '0';
        ab.tipo_combustivel := '0';
        ab.numero_tanque := '0';
        ab.volume_tanque := '0';
        ab.Tag := '0';
        ab.Tag2 := '0';
        ab.integridade := '0';
        ab.checksum:='0';
        ab.st_full := '(0000000000000000000000000000000000)';
      end
  else
      begin
        ab.value:='0';
        ab.habilitacao := '0';
        ab.serial_console := '0';
        ab.total_dinheiro := '0';
        ab.total_litros := '0';
        ab.PU := '0';
        ab.cod_virgula := '0';
        ab.tempo := '00:00:00';
        ab.canal := '99';
        ab.data := '00/00/0000';
        ab.hora := '00:00';
        ab.registro := '0';
        ab.encerrante := '0';
        ab.encerrante_inicial := '0';
        ab.bico_pista := '0';
        ab.tipo_combustivel := '0';
        ab.numero_tanque := '0';
        ab.volume_tanque := '0';
        ab.Tag := '0';
        ab.Tag2 := '0';
        ab.integridade := '0';
        ab.checksum:='0';
        ab.st_full := resposta;
      end;
  resposta:='';
end;


//(a2 G 00005118 000400 003242 1234 3E 0007 04 0511470711 000877 0000555351 0000555026 12 34 56 00987654 0000000000000000 0000000000000000 00 81)
//123 4 56789012 345678 901234 5678 90 1234 56 7890123456 789012 3456789012 3456789012 34 56 78 90123456 7890123456789012 3456789012345678 90 123
//0        1             2           3            4         5         6         7                8         9          0         1
//------------------------------------------------------------------------------------------------------------
// Função LeStructSt                                                                                         -
// Entrada: variável estrutura (referencia)                                                                  -
// Saída: variável estrutura (referencia)                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
Procedure CobLeStructStPAF(var ab:abast2PAF);stdcall; export;
var
  resposta:string;
begin
  resposta:=Get('CobLeStructStPAF',adicionaCheck('(&A2'),1000);
  if (length(resposta)=123) then
    begin
      ab.value:='1';
      ab.total_dinheiro:=copy(resposta,13,6);
      ab.total_litros:=copy(resposta,19,6);
      ab.PU:=copy(resposta,25,4);
      ab.tempo:=formatatempo(copy(resposta,31,4));
      ab.codbico:=copy(resposta,35,2);
      ab.data:=copy(resposta,37,2) + '/' + copy(resposta,43,2) + '/' + copy(resposta,45,2);
      ab.hora:=copy(resposta,39,2) + ':' + copy(resposta,41,2);
      ab.st_full:=resposta;
      ab.registro:=copy(resposta,47,6);
      ab.encerranteF:=copy(resposta,53,10);
      ab.encerranteI:=copy(resposta,63,10);
      ab.numbico:=copy(resposta,73,2);
      ab.codcombustivel:=copy(resposta,75,2);
      ab.numtanque:=copy(resposta,77,2);
      ab.voltanque:=copy(resposta,79,8);
      ab.tag1:=copy(resposta,87,16);
      ab.tag2:=copy(resposta,103,16);
      ab.integridade:=copy(resposta,119,2);
      if ComparaCheck(resposta)=true then
        ab.checksum:='1'
      else
        ab.checksum:='0';
      Incrementa;
    end
  else if resposta='(0)' then
          ab.value:='0'
      else
          ab.value:='0';
  resposta:='';
end;

//------------------------------------------------------------------------------------------------------------
// Função CobLeStructPafFix                                                                                  -
// Entrada: variável estrutura (referencia)                                                                  -
// Saída: variável estrutura (referencia)                                                                    -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
{
123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
0        1         2         3         4         5         6         7         8         9        10        11        12
(a2G0000511800040000324212343E00070405114707110008770000555351000055502612345600987654000000000000000000000000000000000081)
(a2$SSSSSSSSTTTTTTLLLLLLPPPPVVCCCCBBDDHHMMNNAARRRRRRffffffffffiiiiiiiiiibbccttvvvvvvvvIIIIIIIIIIIIIIIIJJJJJJJJJJJJJJJJnnKK)
}
Procedure CobLeStructStPafFix(var ab:abast2PAF);stdcall; export;
var
  resposta:string;
begin
  resposta:=Get('CobLeStructPAFFix',adicionaCheck('(&A2'),1000);
  if (length(resposta)=123) then
    begin
      ab.value:='1';
      ab.total_dinheiro:=copy(resposta,13,6);
      ab.total_litros:=copy(resposta,19,6);
      ab.PU:=copy(resposta,25,4);
      ab.tempo:=formatatempo(copy(resposta,31,4));
      ab.codbico:=copy(resposta,35,2);
      ab.data:=copy(resposta,37,2) + '/' + copy(resposta,43,2) + '/' + copy(resposta,45,2);
      ab.hora:=copy(resposta,39,2) + ':' + copy(resposta,41,2);
      ab.st_full:=resposta;
      ab.registro:=copy(resposta,47,6);
      ab.encerranteF:=copy(resposta,53,10);
      ab.encerranteI:=copy(resposta,63,10);
      ab.numbico:=copy(resposta,73,2);
      ab.codcombustivel:=copy(resposta,75,2);
      ab.numtanque:=copy(resposta,77,2);
      ab.voltanque:=copy(resposta,79,8);
      ab.tag1:=copy(resposta,87,16);
      ab.tag2:=copy(resposta,103,16);
      ab.integridade:=copy(resposta,119,2);
      if ComparaCheck(resposta)=true then
        ab.checksum:='1'
      else
        ab.checksum:='0';
    end
  else if resposta='(0)' then
    ab.value:='0'
  else
    ab.value:='E';
  resposta:='';
end;
//------------------------------------------------------------------------------------------------------------
Function CobReadSalePointer(register: string):CobAbastId;stdcall;export;
var
  answer: string[123];
  command: string;
  stNumber: string[4];
begin
  try
    stNumber := register;
    while length(stNumber) < 4 do stNumber := '0' + stNumber;
    command := '(&LC' + stNumber;
    command := AdicionaCheck(command);
    answer := Get('CobReadSalePointer',command,3000);
    //resposta:='(a230000241900011100041326903E12304814155612130000300035006482195435367008010100FF75F80000000000000000000000000000000000A3)';
    if (length(answer)=123) then
      result := StrToCobAbastId(answer)
  else
     result := CobAbastIdNill;
    except
      result := CobAbastIdNill;
    end;
end;
//------------------------------------------------------------------------------------------------------------


//////////////////////////////////////////////////////////////////////////////////
//
//
//           END        Cob_funtions
//
//
/////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//
//
//           BEGIN        NET_funtions
//
//
/////////////////////////////////////////////////////////////////////////////////


Function NET_AutoPump (bico: WideString ):integer;stdcall; export;
var
  str : string;

begin
    str := bico;
    result := VB_AutPump(str);

end;



Function NET_BlockPump (bico:WideString):integer;stdcall; export;
var
  str: string;
begin
    str :=bico;
    result := VB_BlockPump(str);

end;



Function NET_FreePump(bico: WideString):integer;stdcall;export;
var
  str: string;
begin
    str := bico;
    result := VB_FreePump(str);

end;



Function NET_StopPump(bico: WideString):integer;stdcall;export;
var
  str : string;
  comando,resposta:string;
begin
    str := bico;
    comando:=AdicionaCheck('(&M' + str + 'S');
    resposta:=Get('AlteraModo',comando,1000);
    result := StrToInt(resposta);

end;




Function NET_PausePump(bico: WideString):integer;stdcall;export;
var
  str : string;
  comando,resposta:string;
begin
    str := bico;
    comando:=AdicionaCheck('(&M'+ str +'P' );
    resposta:= Get('AlteraModo',comando,1000);
    result := StrToInt(resposta);

end;




Function NET_CloseSerial:integer;stdcall;export;
begin
    result := FechaSerial;
end;




Function NET_OpenSerial(np:integer):integer;stdcall;export;
begin
    if(InicializaSerial(np)) then result:=1 else result := 0;
end;




Function NET_CloseSocket:integer;stdcall;export;
begin
    if FechaSocket then result:= 1 else result:= 0 ;
end;




Function NET_OpenSocket(ip:Widestring):integer;stdcall;export;
var
   str:string;
begin
    str := ip;
    result := VB_OpenSocket(str);
end;

Function NET_SendReceiveText(st:WideString ; timeout:integer):WideString;stdcall;export;
var
  str:string;
  resposta:string;
begin
    str := st;
    resposta:=Get('SendText',str, timeout);
    result:=resposta;

end;

Function NET_GetSalePAF():WideString;stdcall;export;
var
  resposta:string;
  comando:string;
begin
  comando := '(A299)';
  resposta:= Get('LeAbastecimentoPAF', comando, 1500);
  if(length(resposta) = 123) then
    begin
        result := resposta;
    end
  else
    begin
        result := ('');
    end;

end;

Procedure NET_NextSale;stdcall;export;
begin
    Incrementa;
end;

Function NET_PresetPump( bico,cash : WideString):integer;stdcall;export;
var
    str1,str2:string;
begin
  str1:=bico;
  str2:=cash;
  result := VB_PresetPump(str1, str2);

end;

Function NET_ReadState():WideString; stdcall; export;
     var rec:string;
begin
    rec:=Get('C_ReadState','(&S)',1000);
    result := pchar(rec + #0);
end;

Function NET_ReadTotalsCash(bico:WideString):WideString;stdcall; export;
var
   str :string;
   comando,resposta,encerrante:string;
begin
//

str := bico;
if length(str)=2 then
  begin
  comando:=AdicionaCheck('(&T' + str + '$');

  resposta:=Get('ConsultaEncerrante',comando,3000);
  //messagedlg(resposta,mterror,[mbok],0);

  if length(resposta)=16 then
    begin
    if (copy(resposta,1,5)='(T$'+str) then
      begin
      encerrante:=copy(resposta,6,8);
      try
        result:=(encerrante);
      except
        result:='-1';
      end;
      end
    else
      result:='-1';
    end
  else
    result:='-1';
  end
else
  result:='-1';
end;

Function NET_ReadTotalsVolume(bico:WideString):WideString;stdcall; export;
var comando,resposta,encerrante:string;
begin
if length(bico)=2 then
  begin
  comando:=AdicionaCheck('(&T' + bico + 'l');
  resposta:=Get('ConsultaEncerrante',comando,3000);
  if length(resposta)=16 then
    begin
    if (copy(resposta,1,5)='(TL'+bico) then
      begin
      encerrante:=copy(resposta,6,10);
      try
        result:=encerrante ;
      except
        result:='-1';
      end;
      end
    else
      result:='-1' ;
    end
  else
    result:='-1' ;
  end
else
  result:='-1';
end;

Function NET_Visualize:WideString;stdcall;export;
var
  resposta:string;
begin
  resposta:=Get('LeVisualizacao','(&V)',1000);
  result := resposta;
end;

Function NET_SetPrice(bico,preco:WideString):integer; stdcall; export;
var comando,resposta:string;
begin
      if (length(bico)=2) and (length(preco)=4) then
      begin
        comando:=AdicionaCheck('(&U' + bico + '00' + preco);
        resposta:=Get('AlteraPreco',comando,2000);
                                     //messagedlg(resposta,mterror,[mbok],0);
        if (copy(resposta,1,4)='(U'+bico) then
            result := 1
        else
            result := 0
      end;
end;

//------------------------------------------------------------------------------------------------------------
Function NET_GetClock:WideString;stdcall;export;
var
  str:string;
begin
    str := getclock;
    result := str;
end;

Function NET_SetClock(par:WideString):boolean;stdcall;export;
var
        st:string;
        str:string;
        resposta,comando:string;
        cont:byte;
        dia,hora,minuto:byte;
begin
    st := par;
    str := UpperCase(st);
    if (uppercase(str)='AUTO') then
    begin
        comando:='(&H' + formatdatetime('ddhhnn',now) + ')' ;
        cont:= 0 ;
        resposta:= '';
        while (resposta<>'(&H)') and (cont<3) do
        begin
            resposta:= Get('SetClock',comando,5000);
            inc(cont);
        end;

        if resposta='(&H)' then
        begin
            result:=true;
        end
        else
        begin
            result:=false;
        end;
    end
    else
    begin
        dia:= strtoint(copy(str,1,2));
        hora:=strtoint(copy(str,3,2));
        minuto:=strtoint(copy(str,5,2));
        if parseDate(hora,minuto,dia,monthof(now),yearof(now)) then
        begin
            comando:='(&H' + str + ')';
            cont:= 0;
            resposta:='';

            while (resposta<>'(&H)') and (cont<3) do
            begin
                resposta:=Get('SetClock',comando,5000);
                inc(cont);
            end;

            if resposta='(&H)' then
            begin
              result:=true;
            end
            else
            begin
              result:=false;
            end;

        end
        else
        begin
          result := false;
        end;
    end;
end;

Function NET_Test(par:WideString):WideString;stdcall;export;
begin
  //messagedlg('Parametro de Entrada : ' + par,mtinformation,[mbok],0);
  result := par;
end;



Function test111:string;stdcall;export;
begin
    result:= 'abcdefg';
end;



Function VBNET_ReceiveText():pansichar;stdcall;export;
var rec:string;
begin
    rec:=Get('VBNET_ReceiveText','',2000);
    result := PAnsiChar(rec);
    //messagedlg('Enviando-> :' + result  ,mtinformation,[mbok],0);

end;
//------------------------------------------------------------------------------------------------------------
Function VBNET_Testpansi():pansichar;stdcall;export;
begin
  result := PAnsiChar( 'SUCESSO');
end;
//------------------------------------------------------------------------------------------------------------

Function VBNET_Testpuni():WideString;stdcall;export;
begin
  result := 'SUCESSO';
end;
//------------------------------------------------------------------------------------------------------------




//////////////////////////////////////////////////////////////////////////////////
//
//
//           END        NET_funtions
//
//
/////////////////////////////////////////////////////////////////////////////////
//------------------------------------------------------------------------------------------------------------
// Função XH_GetTotal                                                                                        -
// Entrada: '*BBPPPP'                                                                                        -
// Saída: string                                                                                             -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
function XH_SetPreco(par1:pchar):integer;stdcall; export;
var
  bico,valor:string;
begin
  bico:=copy(par1,1,2);
  valor:=copy(par1,3,4);
  result:=VB_SetPrice(pchar(bico),pchar(valor));
end;

function XH_Test(st:string):integer;stdcall;export;
//var a:string;
begin
  //messagedlg(st,mterror,[mbok],0);
  result:=1;
end;

//------------------------------------------------------------------------------------------------------------
// Função XH_GetTotal                                                                                        -
// Entrada: '*TBB'                                                                                           -
// Saída: string                                                                                             -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
procedure XH_GetTotal(var par1:retorno2);stdcall; export;
var
  enc:encerrante;
begin
  enc:=ConsultaEncerrante(par1.value[1] ,copy(par1.value,2,2) );
  par1.value:=floattostr(enc.Valor);
end;

//------------------------------------------------------------------------------------------------------------
// Função XH_SetModo                                                                                         -
// Entrada: '*MBB' {M=[B,L,A]}                                                                               -
// Saída: string                                                                                             -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
procedure XH_SetModo(var par1:retorno2);stdcall; export;
var
  bico:string;
  modo:char;
  rta:byte;
begin
  modo:=par1.value[1];
  bico:=copy(par1.value,2,2);
  if modo='A' then
    rta:=VB_AutPump(bico)
  else
    if modo='B' then
      rta:=VB_BlockPump(bico)
    else
      if modo='L' then
        rta:=VB_FreePump(bico);
  par1.value:=inttostr(rta);
end;

//------------------------------------------------------------------------------------------------------------
// Função XH_SetClock                                                                                        -
// Entrada: DDHHMM                                                                                           -
// Saída: string                                                                                             -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
function XH_SetClock(par:pchar):boolean;stdcall; export;
var
  comando,resposta:string;
begin
  if (uppercase(par)='AUTO') then
    comando:='(&H' + formatdatetime('ddhhnn',now) + ')'
  else
    comando:='(&H' + par + ')';
  resposta:=Get('SetClock',comando,5000);
  if resposta='(&H)' then result:=true else result:=false;
end;

//------------------------------------------------------------------------------------------------------------
// Função XH_GetAbastecimento                                                                                -
// Entrada: '*MBB' {M=[B,L,A]}                                                                               -
// Saída: string                                                                                             -
// Sub-Functions: None                                                                                       -
//------------------------------------------------------------------------------------------------------------
function XH_GetAbastecimento(var par:shortstring):integer;stdcall; export;
var
  rta:string;
begin
  rta := Get('GetAbastecimento','(&A)',2000);
  setlength(par,250);
  par := rta;
  if length(rta) >= 52 then
    begin
      ShowBalloonMessage('Abastecimento recebido: R$ ' + copy(rta,2,4) + ',' + copy(rta,6,2));
      result := 1;
    end
  else
    result := 0;
end;

function XH_GetAbastecimentoDuplaIdentif(var par:shortstring):integer;stdcall; export;
var
  rta:string;
begin
  rta := Get('GetAbastecimentoDuplaIdentif','(&@66)',2000);
  setlength(par,250);
  par := rta;
  if length(rta) >= 87 then
    begin
      ShowBalloonMessage('Abastecimento recebido: R$ ' + copy(rta,3,4) + ',' + copy(rta,7,2));
      result := 1;
    end
  else
    result := 0;
end;

//------------------------------------------------------------------------------------------------------------
//                                                                                                           -
// Bloco de funções PowerBuilder                                                                             -
//                                                                                                           -
//------------------------------------------------------------------------------------------------------------
Function PB_OpenSerial(np:integer):integer;stdcall; export;
begin
  if InicializaSerial(np) then result:=1 else result:=0;
end;

Function PB_CloseSerial:integer;stdcall; export;
begin
  result:=FechaSerial;
end;

function PB_ReadState:Pchar;stdcall; export;
var
  rec:string;
begin
  rec:=Get('VB_ReadState','(&S)',1000);
  result:=pchar(rec);
end;

Function PB_ReadSale:pchar;stdcall; export;
var
  rec:string;
begin
  rec:=Get('VB_ReadAbastecimento','(&A)',1000);
  result:=pchar(rec);
end;

Function PB_ReadSaleId:pchar;stdcall; export;
var
  rec:string;
begin
  rec:=Get('VB_ReadAbastecimento','(&A67)',1000);
  result:=pchar(rec);
end;

Function PB_ReadSale2Id:pchar;stdcall; export;
var
  rec:string;
begin
  rec:=Get('VB_ReadAbastecimento','(&@66)',1000);
  result:=pchar(rec);
end;

Function PB_NextSale:integer;stdcall; export;
begin
  result:=VB_SendText('(&I)');
end;

// função leitura encerrante PowerBuilder
function PB_ReadTotals(bico:string;tipo:integer):pchar; stdcall; export;
var rta:string;
begin
  try
    if tipo=0 then
      rta:=GetEncerranteVolume(strtoint('$' + bico))
    else if tipo=1 then
      rta:=GetEncerranteValor(strtoint('$' + bico))
    else
      rta:='TIPO INVALIDO';
  finally
    result:=pchar(rta);
  end;
end;

// -------------------------------------------------------------------------------------------------------------------------------------------
function PB_SetPrice(bico:string;valor:integer):integer; stdcall; export;
var comando,resposta:string;
    stPrice:string[4];
begin
try
  stPrice:=inttostr(valor);
  while length(stPrice)<4 do stPrice:='0'+stPrice;
  comando:= AdicionaCheck('(&U' + Bico + '00' + stPrice);
  resposta:=Get('AlteraPreco',comando,2000);
  if resposta='(U'+ Bico + ')' then
    result:=1
  else
    result:=0;
except
  result:=0;
end;
end;

//----------------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------------------
function ExecInClientDLL(aFuncID: Integer; aParams: PChar;aBuff: PChar; aBuffSize: Integer ):integer; stdcall; export;
begin
  if aFuncID=1 then
    if InicializaSerial(strtoint(aParams)) then result:=1 else result:=0
  else if aFuncID=2 then
    if InicializaSocket(aParams) then result:=1 else result:=0
  else if aFuncID=3 then
    result:=ADVPL_ReadSale(aBuff)
  else if aFuncID=4 then
    result:=VB_NextSale
  else if aFuncID=5 then
    result:=ADVPL_ReadState(aBuff);
end;

//////////////////////////////////////////////////////////////////////////////////
//
//
//            C_funtions        NAO TESTADAS !!!!
//
//
/////////////////////////////////////////////////////////////////////////////////

function C_AutoPump(bico:pchar):integer; stdcall; export;
var
    str:string;
begin
    str :=bico;
    result := VB_AutPump(str);
end;

//------------------------------------------------------------------------------------------------------------

function C_BlockPump(bico:pchar):integer; stdcall; export;
var
  str:string;
begin
   str:= bico;
   result := VB_BlockPump(str);
end;


//------------------------------------------------------------------------------------------------------------
function C_FreePump(bico:pchar):integer;stdcall; export;
var
   str:string;
begin
     str := bico;
     result := VB_FreePump(str);
end;

//------------------------------------------------------------------------------------------------------------

procedure C_NextSale; stdcall; export;
begin
    Incrementa;
end;

//------------------------------------------------------------------------------------------------------------
function  C_PresetPump(bico,cash:pchar):integer;stdcall; export;
var
   str1,str2:string;
begin
  str1 := bico;
  str2 := cash;
  result := VB_PresetPump(str1, str2);
end;

Function C_SetPrice(bico,preco:pchar):integer; stdcall; export;
var comando,resposta:string;
begin
  //  messagedlg('bico'+ bico,mterror,[mbok],0);
  //  messagedlg('preco'+ preco,mterror,[mbok],0);
  if (length(bico)=2) and (length(preco)=4) then
  begin
    comando:=AdicionaCheck('(&U' + bico + '00' + preco);
    resposta:=Get('AlteraPreco',comando,2000);
    if copy(resposta,1,4) = '(U' + bico  then
        result := 1
    else
        result := 0
  end;
end;

function C_SetExtendedPrice(nozzle,level,price: pchar):integer;stdcall;export;
var
  command,answer:string[75];
  priceSt: string[6];
begin
  priceSt := price;
  while length(priceSt) < 6 do
    priceSt := '0' + priceSt;
  if (Length(nozzle) = 2) and (Length(priceSt) = 6) then
  begin
    command := AdicionaCheck('(&U' + nozzle + level + '0' + priceSt);
    answer := Get('AlteraPreco',command,2000);
    if copy(answer,1,4) = '(U' + nozzle then
      result := 1
    else
      result := 0;
  end;
end;

// Esse comando está enviando o comando no protocolo Horustech porque não há comando de abastecimento com 6 caracteres no PPL no protocolo Companytec.
// Esse comando novo está sendo implementado por conta da Conecttec, mas ainda não está 100% porque, pelo que sei, o Jorge vai ajustar alguns caracteres no mesmo
Function C_GetSaleExtended():pchar; stdcall; export;
var
  answer:string;
  command:string[12];
begin
  try
    command := '>?000402A1D7';
    answer := Get('GetSaleExtended',command,3000);
    if(length(answer) = 127) then
      begin
        result := pchar(answer + #0);
      end
    else
    begin
      result := pchar('(0)' + #0);
    end;
  except
    result := pchar('ERROR' + #0);
  end;
end;


function C_readState():pchar; stdcall; export;
     var rec:string;
begin
    rec:=Get('C_ReadState','(&S)',1000);
    result := pchar(rec + #0);
end;

//------------------------------------------------------------------------------------------------------------

Function C_GetClock:pchar;stdcall;export;
var
  str:string;
begin
    str := getclock;
    result := pchar(str + #0);
end;

//------------------------------------------------------------------------------------------------------------

Function C_Visualize:pchar;stdcall;export;
var
  resposta:string;
begin
  resposta:=Get('LeVisualizacao','(&V)',1000);
  result := pchar(resposta + #0);

end;

//Leitura de TAG de identificador
Function C_ReadTagFid(idx: integer):pchar;stdcall;export;
var
  comando:string;
  resposta:string;
  stIndice:string[6];
begin
  stIndice:=inttostr(idx);
  while length(stIndice) < 6 do stIndice:= '0' + stIndice;
  comando := adicionacheck('(?LF'+stIndice);

  resposta:=Get('readTagFid',comando,2000);

  if length( resposta ) = 52 then
  begin
    result := pchar(resposta + #0);
  end
  else
  begin
     result := pchar('(0)' + #0);
  end;

end;


//------------------------------------------------------------------------------------------------------------



Function C_SetClock(par:pchar):boolean;stdcall;export;
var
        str:string;
        resposta,comando:string;
        cont:byte;
        dia,hora,minuto:byte;

begin
    str := StrPas(par);
    if (uppercase(str)='AUTO') then
    begin
        comando:='(&H' + formatdatetime('ddhhnn',now) + ')' ;
        cont:= 0 ;
        resposta:= '';
        while (resposta<>'(&H)') and (cont<3) do
        begin
            resposta:= Get('SetClock',comando,5000);
            inc(cont);
        end;

        if resposta='(&H)' then
        begin
            result:=true;
        end
        else
        begin
            result:=false;
        end;
    end
    else
    begin
        dia:= strtoint(copy(str,1,2));
        hora:=strtoint(copy(str,3,2));
        minuto:=strtoint(copy(str,5,2));
        if parseDate(hora,minuto,dia,monthof(now),yearof(now)) then
        begin
            comando:='(&H' + str + ')';
            cont:= 0;
            resposta:='';

            while (resposta<>'(&H)') and (cont<3) do
            begin
                resposta:=Get('SetClock',comando,5000);
                inc(cont);
            end;

            if resposta='(&H)' then
            begin
              result:=true;
            end
            else
            begin
              result:=false;
            end;

        end
        else
        begin
          result := false;
        end;
    end;
end;


Function HRSReadFid( ):pchar;stdcall;export;
var
   resposta:string;
   acum:string;
   comando:string;
//   desc:string;
//   str:string;
//   timeout:integer;
//   index:integer;
   idx : string;
   i: integer;
   st:string;
begin
   i := 0;
   st := '';
   resposta := '';
   acum := '';

   while(i < 16000)  do
   begin
      idx := IntToStr(i);
      while Length(idx) < 6 do
          idx := '0' + idx;

      comando := HRSMontaComando(39, '04' + idx );
      resposta := Get('HRSReadFid', comando, 2000) ;

      st := copy(resposta, 3, 4) ;

      if st = '0002' then
      begin
          break;
      end
      else
      begin
         // messagedlg(resposta,mterror,[mbok],0);
          acum := acum + copy(resposta, 18,16) +';' + copy(resposta, 35, 2) + ';';

          //messagedlg(st,mterror,[mbok],0);
      end;


      inc(i);
   end;
   result := pchar(acum);
end;


//////////////////////////////////////////////////////////////////////////////////
//
//
//           END        C_funtions
//
//
/////////////////////////////////////////////////////////////////////////////////

exports
    C_ReadTagFid,
    test111,
    GetConsoleKey,
    VB_SaveTagFid,
    GetIdentTag,
    LeEncerrante2,
    VB_StopPump,
    NET_Test,
    NET_AutoPump,
    NET_BlockPump,
    NET_FreePump,
    NET_StopPump,
    NET_PausePump,
    NET_CloseSerial,
    NET_OpenSerial,
    NET_CloseSocket,
    NET_OpenSocket,
    NET_SendReceiveText,
    NET_GetSalePAF,
    NET_NextSale,
    NET_PresetPump,
    NET_ReadState,
    NET_ReadTotalsCash,
    NET_ReadTotalsVolume,
    NET_Visualize,
    NET_SetPrice,
    NET_GetClock,
    NET_SetClock,
    C_ReadTotalsVolume3,
    VBNET_Testpuni,
    VBNET_Testpansi,
    VB_TesteVAL,
    VB_TesteREF,
    HRSReadFid,
    C_SetClock,
    ReadPriceLiterLevel0,
    ReadPriceLiterLevel1,
    ReadPriceLiterLevel2,
    C_Visualize,
    C_GetClock,
    getclock,
    C_readState,
    C_SetPrice,
    C_GetSaleExtended,
    C_SetExtendedPrice,
    C_StopPump,
    C_GetSalePAF,
    C_GetSaleTWC,
    C_AutoPump,
    C_BlockPump,
    C_CloseSerial,
    C_CloseSocket,
    C_FreePump,
    C_NextSale,
    C_OpenSerial,
    C_OpenSocket,
    C_OpenSocket2,
    C_SaveTagIdf,
    C_DeleteTagIdf,
    ConsultaPorta,
    C_ReadRegister,
    C_PresetPump,
    C_IncrementIdf,
    C_ClearMemoryIdf,
    C_ReadRegisterIdf,
    C_PushIdfBlackList,
    C_RemoveIdfBlackList,
    C_ReadIdf,
    testepchar,
    SetFullClock,
    VB_OpenSerial,
    VB_CloseSerial,
    VB_SendText,
    VB_ReceiveText,
    FOX_InicializaSerial,
    VB_OpenSocket,
    VB_CloseSocket,
    FOX_GravaPPL,
    FOX_LePPL,
    teste,
    ConsultaEncerrante,
    VBSetPPL,
    LimpaSerial,
    HRSReadTAG,
    LeAbastecimentoFid2,
    InicializaLogSerial,
    STVisualizacao,
    LeStStatus,
    EnviaComando,
    VBInicializaSerial,
    LeStringAb,
    LeAbastecimento,
    RefEncerrante,
    LeStReduzida,
    RefAltPreco,
    RefBloqueiaBico,
    RefAutorizaAbast,
    RefAutoLibera,
    RefParaBomba,
    LeRegistro2,
    RefLePPL,
    RefPreset,
    LeRegistro3,
    LeStatus,
    SetClock,
    LeAbFidFix,
    LeStructSt,
    WriteSerial,
    CS_SendReceiveText,
    LePPL,
    LePPLNivel,
    Incrementa,
    LeVisualizacao,
    CS_SendReceiveText,
    ReadSerial,
    LeSTEncerrante,
    LePart,
    AutorizaAbast,
    LeRegistroFid,
    LeAbastecimentoPAF2,
    LeAbastecimentoPAFReg,
    LeAbastecimentoTWC,
    SetBlackList,
    PushBlackList,
    PopBlackList,
    ClearBlackList,
    BloqueiaBico,
    GetMemoryPointers,
    AutoLibera,
    ParaBomba,
    LeRegistro,
    LeStatus,
    LeStRegistro,
    LeStRegistroFid,
    GetEncerranteValor,
    PB_ReadTotals,
    GetEncerranteVolume,
    SetIntClock,
    SetExtendedWatch,
    AlteraPreco,
    AlteraPrecoComb,
    AlteraPrecoNivel,
    AlteraPrecoEstendidoNivel,
    LePPL2,
    Comunica,
    LeRegistroComp,
    Preset,
    Ver,
    teste2,
    FidIncrementaAbast,
    LeStatusVB,
    LeStatusFid,
    ConsultaCodigoVirgulaPPL,
    VBLeAbastecimento,
    LeAbastecimentoPAF1XE,
    InicializaSerial,
    VBInicializaSerial,
    CobLeStructIDSt,
    STRefAltPreco,
    LeAbFix,
    FechaSerial,
    InicializaATCSocket,
    CobLeEnc,
    CobAlteraPreco,
    VBLeVisualizacao,
    LeStringAbVB,
    CobPreset,
    CobLePPL,
    LeStringX,
    C_SendReceiveText,
    LeStringAb,
    CobSetClock,
    clearTagFid,
    SetPreset,
    SetParaBomba,
    SetIntClock,
    SetExtendedWatch,
    SetAutorizaAbast,
    SetBloqueiaBico,
    deleteTagFid,
    CobLeStructStId,
    CobReadSalePointer,
    SetAutoLibera,
    VBSetAutorizaAbast,
    InicializaSocket2,
    InicializaATCSerial,
    CobLeStructIDSt,
    VBSetAutoLibera,
    CobLeStructStPafFix,
    HRSSaveTAG,
    VBSetBloqueiaBico,
    SetPrice,
    LeAbFidFix,
    VBNET_ReceiveText,
    VB_STReceiveText,
    VB_ReadSale,
    VB_ReadSaleFmGreaterFour,
    VB_NextSale,
    VB_ReadSalePAF,
    VB_SetPrice,
    VB_ReadPrice,
    VB_SetPriceLevel,
    VB_ReadLevelPPL,
    VB_SetPrice2,
    VB_ReadState,
    VB_SetState,
    VB_AutPump,
    VB_BlockPump,
    VB_FreePump,
    VB_ReadTotalsCash,
    VB_ReadTotalsVolume,
    VB_ReadTotalsVolumeExtended,
    VB_PresetPump,
    VB_SendReceiveText,
    VB_ReadSaleId,
    VB_ReadSale2Id,
    VB_ReadSale2,
    VB_ReadSale3,
    SetAlteraPreco,
    CobLeVis,
    LeStructPPL,
    LeStructIDStFix,
    VBLePPL,
    LeStStatus2,
    LeStructEncerrante,
    InicializaSocket2,
    FechaSerialVB,
    XH_GetTotal,
    XH_GetAbastecimento,
    XH_GetAbastecimentoDuplaIdentif,
    PortOpen,
    CobLeStructSt,
    InicializaSocket2,
    ExecInClientDLL,
    LeStructStFix,
    LeAbastecimentoFid,
    SendReceiveText,
    ConfigFid,
    CobLeEnc2,
    DesconfigFid,
    PB_SetPrice,
    SendReceiveText,
    FidIdent,
    XH_Test,
    FidIncrementa,
    FidStatus,
    FOX_ReadState,
    Connected,
    FidModo,
    readTagFid,
    FidAciona,
    FidSetClock,
    LeAbFid2Fix,
    EscreveSerial,
    FidLeRegistro,
    LeAbastecimentoPAF1,
    LeAbastecimentoPAF1Fix,
    LeAbastecimentoPAF1XE,
    XEGetAbastecimento,
    CobLeStructStPAF,
    ATCInventoryString,
    XH_SetPreco,
    LeEvento,
    EscreveSocket,
    LeSocket,
    InicializaSocket,
    FechaSocket,
    GetAbastecimento,
    C_ReadTotalsCash,
    C_ReadTotalsVolume,
    C_GetSale,
    LePPL3,
    GetAbastecimentoIdent,
    TxRxSerial,
    XH_SetModo,
    XH_GetAbastecimento,
    XH_SetClock,
    LeStructEncerrante2,
    saveTagFid,
    PresetValue,
    SocketOpen,
    InicializaSocket3,
    GetVisualizacao,
    GetVisualizacaoId,
    SetMode,
    Unlock,
    Lock,
    Authorize,
    GetEncerrante,
    GetRegistro,
    C_ReadTotalsVolume2,
    GetAbastecimento2Ident,
    XH_AbastToFile,
    XH_AbastDuplaIdentToFile,
    GetAbastecimentoIdent,
    GetAbastecimento,
    PresetId,
    ATCInventoryReport,
    GetConsoleVersion,
    SetUnitPrice,
    TestCallback,
    ReadTotalsCash,
    ReadTotalsVolume,
    GetSaleVolume,
    GetSalePoint,
    GetSaleIndex,
    PB_OpenSerial,
    PB_CloseSerial,
    PB_ReadState,
    PB_ReadSale,
    PB_ReadSaleId,
    PB_ReadSale2Id,
    PB_ReadTotals,
    PB_NextSale,
    presetIdf,
    preset2,
    PB_sendReceiveText,
    HRSGetSalePAF,
    CobReadIdfOfMemory,
    CobClearMemoryIdf,
    CobSaveTagFid,
    CobDeleteTagIdf,
    CobPushIdfBlackList,
    CobPopIdfBlackList,
    CobClearIdfBlackList,
    lerTagIdf;
    
begin
DLLProc:=LibraryProc;
DLLProc(DLL_PROCESS_ATTACH);
IsMultiThread := True;
end.



